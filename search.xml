<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Nginx</title>
    <url>/2022/12/25/Nginx/</url>
    <content><![CDATA[<hr>
<p><em><strong>Nginx</strong></em> 是高性能的 <em><strong>HTTP</strong></em> 和反向代理的服务器，处理高并发能力是十分强大的，能经受高负载的考验，有报告表明能支持高达 50,000 个并发连接数。</p>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p><strong>正向代理</strong></p>
<p><em><strong>Nginx</strong></em> 不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。 正向代理：如果把局域网外的 <em><strong>Internet</strong></em> 想象成一个巨大的资源库，则局域网中的客户端要访问 <em><strong>Internet</strong></em>，则需要通过代理服务器来访问，这种代理服务就称为正向代理。</p>
<p><u>需要在客户端配置代理服务器进行指定网站访问</u>。</p>
<p><img src="/2022/12/25/Nginx/20211022162954.png" alt="20211022162954"></p>
<p><strong>反向代理</strong></p>
<p>反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，<u>暴露的是代理服务器地址，隐藏了真实服务器 <em><strong>IP</strong></em> 地址</u>。</p>
<img src="/2022/12/25/Nginx/20211022163509.png" style="zoom:50%;">



<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p><strong>单一模式</strong></p>
<p><img src="/2022/12/25/Nginx/20211022164011.png" alt="20211022164011"></p>
<p><strong>负载均衡</strong></p>
<p>增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，即负载均衡。</p>
<p><img src="/2022/12/25/Nginx/20211022164555.png" alt="20211022164555"></p>
<h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。</p>
<p><img src="/2022/12/25/Nginx/20211022164918.png" alt="20211022164918"></p>
<h1 id="安装和启动"><a href="#安装和启动" class="headerlink" title="安装和启动"></a>安装和启动</h1><p>官网：<a href="http://nginx.org/">http://nginx.org/</a></p>
<blockquote>
<ol>
<li>需要安装 <em><strong>gcc-c++</strong></em> 编译器</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install gcc-c++</span><br><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装 <em><strong>pcre</strong></em> 包</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>安装 <em><strong>zlib</strong></em> 包</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <em><strong>&#x2F;opt&#x2F;</strong></em>  下载 <em><strong>nginx</strong></em></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://nginx.org/download/nginx-1.19.9.tar.gz</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>解压并进入 <em><strong>nginx</strong></em> 目录</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf nginx-1.19.9.tar.gz</span><br><span class="line"><span class="built_in">cd</span> nginx-1.19.9</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>使用 <em><strong>nginx</strong></em> 默认配置</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>编译安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>



<p>默认安装路径：<code>/usr/local/nginx</code></p>
<p>启动：<code>cd /usr/local/nginx/sbin</code></p>
<p>默认启动脚本：<code>./nginx</code></p>
<p><img src="/2022/12/25/Nginx/20211022170259.png" alt="20211022170259"></p>
<p>成功启动后可以进行访问：<code>172.16.88.168:80</code>（需要关闭防火墙）</p>
<p>默认端口：80</p>
</blockquote>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/nginx/sbin <span class="comment"># 默认安装路径</span></span><br><span class="line"></span><br><span class="line">./nginx -v <span class="comment"># 查看 nginx 版本号 </span></span><br><span class="line"></span><br><span class="line">./nginx <span class="comment"># 启动 nginx</span></span><br><span class="line"></span><br><span class="line">./nginx -s stop <span class="comment"># 停止 nginx </span></span><br><span class="line"></span><br><span class="line">./nginx -s reload <span class="comment"># 重新加载 nginx </span></span><br></pre></td></tr></table></figure>






<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p><em><strong>nginx.conf</strong></em></p>
<p>默认路径：***&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf***</p>
<blockquote>
<p><em><strong>全局块</strong></em></p>
<p>主要包括配置运行 <em><strong>Nginx</strong></em> 服务器的用户（组）、允许生成的 <em><strong>worker process</strong></em> 数，进程 <em><strong>PID</strong></em> 存放路径、日志存放路径和类型以及配置文件的引入等。</p>
<p><img src="/2022/12/25/Nginx/20211022214703.png" alt="20211022214703"></p>
<p><em><strong>events块</strong></em></p>
<p><em><strong>events</strong></em> 块涉及的指令主要影响 <em><strong>Nginx</strong></em> 服务器与用户的网络连接，常用的设置包括是否开启对多 <em><strong>work process</strong></em> 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 <em><strong>word process</strong></em> 可以同时支持的最大连接数等。</p>
<p><img src="/2022/12/25/Nginx/20211022214811.png" alt="20211022214811"></p>
<p><em><strong>http块</strong></em></p>
<p>这算是 <em><strong>Nginx</strong></em> 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。 需要注意的是：<em><strong>http</strong></em> 块也可以包括 <em><strong>http</strong></em> 全局块、<em><strong>server</strong></em> 块。</p>
<ol>
<li><p><em><strong>http 全局块</strong></em></p>
<p><em><strong>http</strong></em> 全局块配置的指令包括文件引入、<em><strong>MIME-TYPE</strong></em> 定义、日志自定义、连接超时时间、单链接请求数上限等。</p>
</li>
<li><p><em><strong>server块</strong></em></p>
<p>这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了 节省互联网服务器硬件成本。</p>
<p>每个 <em><strong>http</strong></em> 块可以包括多个 <em><strong>server</strong></em> 块，而每个 <em><strong>server</strong></em> 块就相当于一个虚拟主机。 而每个 <em><strong>server</strong></em> 块也分为全局 <em><strong>server</strong></em> 块，以及可以同时包含多个 <em><strong>locaton</strong></em> 块。</p>
<ol>
<li><p><em><strong>全局 server 块</strong></em></p>
<p>最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。</p>
</li>
<li><p><em><strong>location 块</strong></em></p>
<p>一个 <em><strong>server</strong></em> 块可以配置多个 <em><strong>location</strong></em> 块。</p>
<p>这块的主要作用是基于 <em><strong>Nginx</strong></em> 服务器接收到的请求字符串（例如 <em><strong>server_name&#x2F;uri-string</strong></em>），对虚拟主机名称（也可以是 <em><strong>IP</strong></em> 别名）之外的字符串（例如 前面的 <em><strong>&#x2F;uri-string</strong></em>）进行匹配，对特定的请求进行处理。地址定向、数据缓 存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</p>
</li>
</ol>
</li>
</ol>
<p><img src="/2022/12/25/Nginx/20211022214847.png" alt="20211022214847"></p>
</blockquote>
<h2 id="反向代理-1"><a href="#反向代理-1" class="headerlink" title="反向代理"></a>反向代理</h2><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例 1"></a>案例 1</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实现效果：使用 nginx 进行反向代理，访问 www.test.com 直接跳转到 127.0.0.1:8080</span><br></pre></td></tr></table></figure>

<p>访问的流程：</p>
<p><img src="/2022/12/25/Nginx/20211022235512.png" alt="20211022235512"></p>
<p>如何启动 <em><strong>tomcat</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// tomcat安装路径bin目录</span><br><span class="line">// 默认端口8080</span><br><span class="line">./startup.sh</span><br></pre></td></tr></table></figure>



<ol>
<li>本地 <em><strong>hosts</strong></em> 文件进行域名和 <em><strong>ip</strong></em> 对应配置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 最后一行加上</span><br><span class="line"># 虚拟机对应的ip</span><br><span class="line">172.16.88.168 www.test.com</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <em><strong>nginx</strong></em> 进行请求转发的配置（反向代理配置）</li>
</ol>
<p><img src="/2022/12/25/Nginx/20211022235420.png" alt="20211022235420"></p>
<ol start="3">
<li>启动 <em><strong>nginx</strong></em></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 默认路径 /usr/local/nginx/sbin/</span><br><span class="line">./nginx -c /opt/etc/nginx.conf # 配置文件的路径</span><br></pre></td></tr></table></figure>



<p>最终：访问 <code>wwww.test.com</code> 跳转到 <em><strong>tomcat</strong></em> 成功启动页面。</p>
<p><img src="/2022/12/25/Nginx/20211022235621.png" alt="20211022235621"></p>
<hr>
<h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例 2"></a>案例 2</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实现效果：</span><br><span class="line">使用 nginx 反向代理，根据访问的路径跳转到不同端口的服务中 nginx 监听端口为 9001</span><br><span class="line">访问 http://172.16.88.168:9001/edu/ 直接跳转到 127.0.0.1:8080</span><br><span class="line">访问 http://172.16.88.168:9001/vod/ 直接跳转到 127.0.0.1:8081</span><br></pre></td></tr></table></figure>

<ol>
<li><p>准备两个 <em><strong>tomcat</strong></em> 服务器（略）</p>
</li>
<li><p>配置 <em><strong>nginx.conf</strong></em></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">     listen       9001;</span><br><span class="line">     server_name  172.16.88.168;</span><br><span class="line"></span><br><span class="line">     location ~ /edu/ &#123;</span><br><span class="line">         proxy_pass http://127.0.0.1:8080;</span><br><span class="line">     &#125;</span><br><span class="line">     location ~ /vod/ &#123;</span><br><span class="line">         proxy_pass http://127.0.0.1:8081;</span><br><span class="line">     &#125;</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a><em>proxy_pass</em></h3><blockquote>
<p>格式： <em><strong>proxy_pass URL</strong></em></p>
<p>URL包含：传输协议、主机名、<em><strong>uri</strong></em></p>
</blockquote>
<p><em><strong>url</strong></em> 的 &#x2F; 问题</p>
<blockquote>
<p>在 <em><strong>nginx</strong></em> 中配置 <em><strong>proxy_pass</strong></em> 时，当在后面的 <em><strong>url</strong></em> 加上了&#x2F;，相当于是绝对根路径，则 <em><strong>nginx</strong></em> 不会把 <em><strong>location</strong></em> 中匹配的路径部分代理；</p>
<p>如果没有 &#x2F;，则会把匹配的路径部分也给代理。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">假设 server_name:192.168.1.10</span><br><span class="line">		请求:http://192.168.1.10/a/a.html</span><br><span class="line"></span><br><span class="line">示例1：</span><br><span class="line">location /a/</span><br><span class="line">&#123;</span><br><span class="line">    proxy_pass http://192.168.1.10;</span><br><span class="line">    ...</span><br><span class="line">&#125;结果1：http://192.168.1.10/a/a.html</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">location /a/</span><br><span class="line">&#123;</span><br><span class="line">    proxy_pass http://192.168.1.10/;</span><br><span class="line">    ...</span><br><span class="line">&#125;结果2：http://192.168.1.10/a.html</span><br><span class="line"></span><br><span class="line">示例3：</span><br><span class="line">location /a/</span><br><span class="line">&#123;</span><br><span class="line">    proxy_pass http://192.168.1.10/nanase;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">结果3：http://192.168.1.10/nanasea.html</span><br><span class="line"></span><br><span class="line">示例4：</span><br><span class="line">location /a/</span><br><span class="line">&#123;</span><br><span class="line">    proxy_pass http://192.168.1.10/nanase/;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">结果4：http://192.168.1.10/nanase/a.html</span><br></pre></td></tr></table></figure>



<p><strong><u>为了方便记忆和规范配置，建议所有的 <em>proxy_pass</em> 后的 <em>url</em> 都以 &#x2F; 结尾。</u></strong></p>
<h3 id="location"><a href="#location" class="headerlink" title="location"></a><em>location</em></h3><p>该指令用于匹配 <em><strong>URL</strong></em>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location [ = | ~ | ~* | ^~ ] uri &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>=</code> </p>
<p>用于不含正则表达式的 <em><strong>uri</strong></em> 前，要求请求字符串与 <em><strong>uri</strong></em> 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。</p>
<p><code>~</code></p>
<p>用于表示 <em><strong>uri</strong></em> 包含正则表达式，并且区分大小写。</p>
<p><code>~*</code></p>
<p>用于表示 <em><strong>uri</strong></em> 包含正则表达式，并且不区分大小写。</p>
<p><code>^~</code></p>
<p>用于不含正则表达式的 <em><strong>uri</strong></em> ，要求 <em><strong>Nginx</strong></em> 服务器找到标识 <em><strong>uri</strong></em> 和请求 符串匹配度最高的 <em><strong>location</strong></em> 后，立即使用此 <em><strong>location</strong></em> 处理请求，而不再使用 <em><strong>location</strong></em> 块中的正则 <em><strong>uri</strong></em> 和请求字符串做匹配。</p>
</blockquote>
<p><strong><u><em>注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识。</em></u></strong>		 		</p>
<p>​			 					 					 				</p>
<h2 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>增加服务器的数量，然后将请求分发到各个服务器上面。即将原先请求集中到单个服务器上转化为将请求分发到多个服务器上，将负载分发到不同的服务器，即负载均衡。</p>
<h4 id="案例-1-1"><a href="#案例-1-1" class="headerlink" title="案例 1"></a>案例 1</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实现效果：浏览器地址栏输入地址 http://172.16.88.168/edu/a.html，负载均衡效果，平均分担 8080 和 8081 端口中。</span><br></pre></td></tr></table></figure>

<ol>
<li>准备两个 <em><strong>tomcat</strong></em> 服务器（略）</li>
<li>配置 <em><strong>nginx.conf</strong></em> 文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	...</span><br><span class="line">	upsteam myserver &#123;</span><br><span class="line">		ip_hash;</span><br><span class="line">		server 172.16.88.168:8080 weight=1;</span><br><span class="line">		server 172.16.88.168:8081 weight=1;</span><br><span class="line">	&#125;</span><br><span class="line">	server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  172.16.88.168;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://myserver;</span><br><span class="line">            root html;</span><br><span class="line">            index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"> 				...</span><br><span class="line"> 		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h3><ul>
<li><p><em><strong>轮询</strong></em>（默认）<br>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 <em><strong>down</strong></em> 掉，能自动剔除。</p>
</li>
<li><p><em><strong>weight</strong></em><br><em><strong>weight</strong></em> 代表权重默认为 1，权重越高被分配的客户端越多。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream server_pool &#123;</span><br><span class="line">	server 192.168.5.21 weight=10; </span><br><span class="line">	server 192.168.5.22 weight=10; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><em><strong>ip_hash</strong></em><br>每个请求按访问 <em><strong>ip</strong></em> 的 <em><strong>hash</strong></em> 结果分配，这样每个访客固定访问一个后端服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream server_pool &#123;</span><br><span class="line">	ip_hash;</span><br><span class="line">	server 192.168.5.21:80; </span><br><span class="line">	server 192.168.5.22:80; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><em><strong>fair</strong></em>（第三方） 按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream server_pool &#123; </span><br><span class="line">	server 192.168.5.21:80; </span><br><span class="line">	server 192.168.5.22:80; </span><br><span class="line">	fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="动静分离-1"><a href="#动静分离-1" class="headerlink" title="动静分离"></a>动静分离</h2><p><em><strong>Nginx</strong></em> 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和 静态页面物理分离。</p>
<p>一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案。</p>
<p>另外一种方法就是动态跟静态文件混合在一起发布，通过 <em><strong>nginx</strong></em> 来分开。</p>
<p><img src="/2022/12/25/Nginx/20211027141844.png" alt="20211027141844"></p>
<h4 id="案例-1-2"><a href="#案例-1-2" class="headerlink" title="案例 1"></a>案例 1</h4><ol>
<li>在 <em><strong>linux</strong></em> 系统中准备静态资源，用于进行访问</li>
<li>配置 <em><strong>nginx</strong></em> 文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">     listen       80;</span><br><span class="line">     server_name  172.16.88.168;</span><br><span class="line"></span><br><span class="line">     location /html/ &#123;</span><br><span class="line">     	root /data/;</span><br><span class="line">     	index index.html index.htm;</span><br><span class="line">     	# 访问 /data/html/.*html</span><br><span class="line">     &#125;</span><br><span class="line">     location /image/ &#123;</span><br><span class="line">     	root /data/;</span><br><span class="line">     	autoindex on; # 列出文件目录</span><br><span class="line">     &#125;</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="高可用集群"><a href="#高可用集群" class="headerlink" title="高可用集群"></a>高可用集群</h2><p><img src="/2022/12/25/Nginx/20211027142139.png" alt="20211027142139"></p>
<p>即主服务器宕机，启动备用服务器。</p>
<h4 id="案例-1-3"><a href="#案例-1-3" class="headerlink" title="案例 1"></a>案例 1</h4><p><em><strong>keepalive + nginx</strong></em></p>
<p><strong>高可用集群（主从模式）</strong></p>
<ol>
<li><p>准备两台服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务器ip：</span><br><span class="line">	192.168.17.128</span><br><span class="line">	192.168.17.131</span><br></pre></td></tr></table></figure>
</li>
<li><p>两台服务器安装 <em><strong>keepalive</strong></em> 和 <em><strong>nginx</strong></em> （略）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install keepalive-y</span><br></pre></td></tr></table></figure>
</li>
<li><p>完成高可用配置（主从模式）</p>
<p>在 <code>/usr/local/src/</code> 添加检测脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">A=`ps -C nginx –no-header |<span class="built_in">wc</span> -l` <span class="keyword">if</span> [ <span class="variable">$A</span> -eq 0 ];<span class="keyword">then</span></span><br><span class="line">/usr/local/nginx/sbin/nginx</span><br><span class="line"><span class="built_in">sleep</span> 2</span><br><span class="line"><span class="keyword">if</span> [ `ps -C nginx --no-header |<span class="built_in">wc</span> -l` -eq 0 ];<span class="keyword">then</span></span><br><span class="line">        killall keepalived</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>配置主服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主要修改 keepalive 配置文件</span></span><br><span class="line"><span class="comment"># /etc/keepalived/keepalived.conf</span></span><br><span class="line"><span class="comment"># 主和备服务器修改不同地方</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局配置</span></span><br><span class="line">global_defs &#123;</span><br><span class="line">	notification_email &#123; </span><br><span class="line">		acassen@firewall.loc </span><br><span class="line">		failover@firewall.loc </span><br><span class="line">		sysadmin@firewall.loc</span><br><span class="line">&#125;</span><br><span class="line">	notification_email_from </span><br><span class="line">	Alexandre.Cassen@firewall.loc smtp_server 192.168.17.129</span><br><span class="line">	smtp_connect_timeout 30</span><br><span class="line">	router_id LVS_DEVEL <span class="comment"># 访问主机服务器名字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 脚本配置</span></span><br><span class="line">vrrp_script chk_http_port &#123; </span><br><span class="line">	script <span class="string">&quot;/usr/local/src/nginx_check.sh&quot;</span> <span class="comment"># 脚本</span></span><br><span class="line">	interval 2 <span class="comment"># 检测脚本执行的间隔</span></span><br><span class="line">	weight 2 <span class="comment"># 设置当前服务器的权重</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 虚拟ip配置</span></span><br><span class="line">vrrp_instance VI_1 &#123; </span><br><span class="line">	state MASTER <span class="comment"># 主服务器：MASTER 备份服务器：BACKUP </span></span><br><span class="line">	interface ens33 <span class="comment"># 网卡</span></span><br><span class="line">	virtual_router_id 51 <span class="comment"># 主备机的id必须相同</span></span><br><span class="line">	priority 100 <span class="comment"># 优先级；主机值较大，备份机值较小 </span></span><br><span class="line">	advert_int 1 <span class="comment"># 时间间隔检测</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 权限</span></span><br><span class="line">	authentication &#123; </span><br><span class="line">		auth_type PASS</span><br><span class="line">		auth_pass 1111 </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 虚拟ip</span></span><br><span class="line">	virtual_ipaddress &#123;</span><br><span class="line">		192.168.17.50 <span class="comment"># VRRP H 虚拟地址</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 <em><strong>nginx</strong></em> 和 <em><strong>keepalived</strong></em> 服务</p>
</li>
</ol>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="master-amp-worker"><a href="#master-amp-worker" class="headerlink" title="master&amp;worker"></a>master&amp;worker</h2><p><img src="/2022/12/25/Nginx/20211027144904.png" alt="20211027144904"></p>
<h2 id="worker如何工作"><a href="#worker如何工作" class="headerlink" title="worker如何工作"></a>worker如何工作</h2><img src="https://gitee.com/tsuiraku/typora/raw/master/img/%E6%88%AA%E5%B1%8F2021-10-27%2014.59.12.png" style="zoom:50%;">



<h2 id="一个master多个worker"><a href="#一个master多个worker" class="headerlink" title="一个master多个worker"></a>一个master多个worker</h2><ul>
<li>可以使用 <em><strong>nginx –s reload</strong></em> 热部署，利用 <em><strong>nginx</strong></em> 进行热部署操作；</li>
<li>每个 <em><strong>woker</strong></em> 是独立的进程，如果有其中的一个 <em><strong>woker</strong></em> 出现问题，其他 <em><strong>woker</strong></em> 独立的， 继续进行争抢，实现请求过程，不会造成服务中断。</li>
</ul>
<h2 id="worker的数量"><a href="#worker的数量" class="headerlink" title="worker的数量"></a>worker的数量</h2><p><em><strong>nginx</strong></em> 类似 <em><strong>redis</strong></em> 都采用 <em><strong>io</strong></em> 多路复用机制，每个 <em><strong>worker</strong></em> 都是一个独立的进程。</p>
<p>即 <em><strong>worker</strong></em> 数量和服务器的 <em><strong>cpu</strong></em> 数量相等最合适。</p>
<h2 id="连接数worker-connection"><a href="#连接数worker-connection" class="headerlink" title="连接数worker_connection"></a>连接数worker_connection</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一个：发送请求，占用了 woker 的几个连接数? </span><br><span class="line"></span><br><span class="line">答案: 2 或者 4 </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第二个：nginx 有一个 master，有 4 个 woker，每个 woker 支持最大的连接数 1024，支持的最大并发数是多少?</span><br><span class="line"></span><br><span class="line">worker支持的最大连接数：4 * 1024</span><br><span class="line"></span><br><span class="line">普通的静态访问最大并发数是：</span><br><span class="line">	worker_connections * worker_processes / 2</span><br><span class="line">	1024 * 4 / 2</span><br><span class="line"></span><br><span class="line">而如果是 HTTP 作 为反向代理来说，最大并发数量应该是：</span><br><span class="line">	worker_connections * worker_processes / 4</span><br><span class="line">	1024 * 4 / 4</span><br></pre></td></tr></table></figure>



<ul>
<li><a href="https://www.bilibili.com/video/BV1zJ411w7SV?from=search&seid=5693495616515059218&spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1zJ411w7SV?from=search&amp;seid=5693495616515059218&amp;spm_id_from=333.337.0.0</a>)</li>
</ul>
]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2023/02/02/redis/</url>
    <content><![CDATA[<hr>
<p><em><strong>Redis</strong></em> 是典型的 <em><strong>NoSQL</strong></em> 数据库。</p>
<p><em><strong>redis官网</strong></em>：<a href="https://redis.io/download">https://redis.io/download</a> </p>
<blockquote>
<p><em><strong>Redis</strong></em> 是一个开源的 <em><strong>key-value</strong></em> 存储系统。</p>
<p>和 <em><strong>Memcached</strong></em> 类似，它支持存储的 <em><strong>value</strong></em> 类型相对更多，包括 <em><strong>string、list、set、zset、sorted set、hash</strong></em>。</p>
<p>这些数据类型都支持 <em><strong>push&#x2F;pop、add&#x2F;remove</strong></em> 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</p>
<p>在此基础上，<em><strong>Redis</strong></em> 支持各种不同方式的排序。</p>
<p>与 <em><strong>memcached</strong></em>一样，为了保证效率，数据都是缓存在内存中。</p>
<p>区别的是 <em><strong>Redis</strong></em> 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</p>
<p>并且在此基础上实现了<em><strong>master-slave</strong></em> （主从）同步。</p>
<p>单线程 + <em><strong>IO</strong></em> 多路复用。</p>
</blockquote>
<h1 id="安装和启动"><a href="#安装和启动" class="headerlink" title="安装和启动"></a>安装和启动</h1><blockquote>
<p>安装 <em><strong>C</strong></em> 语言的编译环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install centos-release-scl scl-utils-build</span><br><span class="line">yum install -y devtoolset-8-toolchain</span><br><span class="line">scl enable devtoolset-8 bash</span><br></pre></td></tr></table></figure>

<p>通过 <em><strong>wget</strong></em> 下载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://download.redis.io/releases/redis-6.2.6.tar.gz</span><br><span class="line"></span><br><span class="line">// 下载路径：/opt</span><br></pre></td></tr></table></figure>

<p>解压至当前目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf redis-6.2.6.tar.gz </span><br></pre></td></tr></table></figure>

<p>解压完成后进入目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd redis-6.2.6</span><br></pre></td></tr></table></figure>

<p>在当前目录下执行 <em><strong>make</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>默认安装在 <code>/usr/local/bin</code></p>
<p><img src="/2023/02/02/redis/18.png" alt="ss"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-benchmark：性能测试工具，可以在自己本子运行，看看自己本子性能如何</span><br><span class="line">redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲</span><br><span class="line">redis-check-dump：修复有问题的dump.rdb文件</span><br><span class="line">redis-sentinel：Redis集群使用</span><br><span class="line">redis-server：Redis服务器启动命令</span><br><span class="line">redis-cli：客户端，操作入口</span><br></pre></td></tr></table></figure>



<p>前台启动：***&#x2F;usr&#x2F;local&#x2F;bin*** 目录下启动 <em><strong>redis</strong></em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-server(前台启动)</span><br></pre></td></tr></table></figure>



<p>后台启动：</p>
<ul>
<li><p>安装 <em><strong>redis</strong></em> 的目录 <em><strong>&#x2F;opt&#x2F;redis-6.2.6</strong></em> 中将 <em><strong>redis.conf</strong></em> 复制到任意一个文件夹下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp redis.conf /etc/redis.conf</span><br><span class="line">// 将redis.conf复制到/etc/下</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 <em><strong>&#x2F;etc&#x2F;redis.conf</strong></em> 配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># daemonize no 修改为 daemonize yes</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/02/redis/20211021.png" alt="s"></p>
</li>
<li><p><em><strong>&#x2F;usr&#x2F;local&#x2F;bin</strong></em> 目录下启动 <em><strong>redis</strong></em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure></li>
</ul>
<p>关闭 <em><strong>redis</strong></em></p>
<ul>
<li><em><strong>kill</strong></em> 进程</li>
<li>命令 <em><strong>shutdown</strong></em></li>
</ul>
</blockquote>
<p><u><strong>默认端口号：6379</strong></u></p>
<h1 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h1><ul>
<li><p>解决 <em><strong>CPU</strong></em> 及内存压力</p>
<p><img src="/2023/02/02/redis/20211021213413082.png" alt="20211021213413082"></p>
</li>
<li><p>解决 <em><strong>IO</strong></em> 压力</p>
<p><img src="/2023/02/02/redis/20211021213423883.png" alt="20211021213423883"></p>
</li>
</ul>
<p><em><strong>NoSQL（ NoSQL &#x3D; Not Only SQL ）</strong></em>，意即不仅仅是 <em><strong>SQL</strong></em>，泛指非关系型的数据库。 </p>
<p><em><strong>NoSQL</strong></em> 不依赖业务逻辑方式存储，而以简单的 <em><strong>key-value</strong></em> 模式存储。因此大大的增加了数据库的扩展能力。</p>
<ul>
<li>不遵循 <em><strong>SQL</strong></em> 标准。</li>
<li>不支持 <em><strong>ACID</strong></em>。</li>
<li>远超于 <em><strong>SQL</strong></em> 的性能。</li>
</ul>
<p><strong>适用于的场景</strong></p>
<ul>
<li>对数据高并发的读写；</li>
<li>海量数据的读写；</li>
<li>对数据高可扩展性的。</li>
</ul>
<p><strong>不适用的场景</strong></p>
<ul>
<li>需要事务支持；</li>
<li>基于 <em><strong>sql</strong></em> 的结构化查询存储，处理复杂的关系，需要即席查询。</li>
</ul>
<p>常见的 <em><strong>NoSQL</strong></em> 数据库</p>
<ul>
<li>Redis</li>
<li>MongoDB</li>
</ul>
<p>大数据时代常用的数据库类型</p>
<ul>
<li><p>行式数据库</p>
<p><img src="/2023/02/02/redis/20211021215032857.png" alt="20211021215032857"></p>
</li>
<li><p>列式数据库</p>
<p><img src="/2023/02/02/redis/20211021215041246.png" alt="20211021215041246"></p>
</li>
</ul>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p><em><strong>redis.conf</strong></em></p>
<h2 id="Units"><a href="#Units" class="headerlink" title="Units"></a><em><strong>Units</strong></em></h2><blockquote>
<p>单位，配置大小单位，开头定义了一些基本的度量单位，只支持 <em><strong>bytes</strong></em>，不支持 <em><strong>bit</strong></em>。</p>
<p>大小写不敏感。</p>
</blockquote>
<p><img src="/2023/02/02/redis/20211022133010.png" alt="20211022 133010"></p>
<h2 id="INCLUDES"><a href="#INCLUDES" class="headerlink" title="INCLUDES"></a><em><strong>INCLUDES</strong></em></h2><blockquote>
<p>包含，多实例的情况可以把公用的配置文件提取出来。</p>
</blockquote>
<p><img src="/2023/02/02/redis/20211022133249.png" alt="20211022 133249"></p>
<h2 id="NETWORK"><a href="#NETWORK" class="headerlink" title="NETWORK"></a><em><strong>NETWORK</strong></em></h2><blockquote>
<p>网络相关配置。</p>
<p><em><strong>bind</strong></em></p>
<p>默认情况 <code>bind=127.0.0.1</code> 只能接受本机的访问请求。</p>
<p>不写的情况下，无限制接受任何 <em><strong>ip</strong></em> 地址的访问。</p>
<p>生产环境肯定要写你应用服务器的地址，服务器是需要远程访问的，*<u>所以需要将其注释掉</u>*。</p>
<p>如果开启了<em><strong>protected-mode</strong></em>，那么在没有设定 <em><strong>bind ip</strong></em> 且没有设密码的情况下，<em><strong>Redis</strong></em> 只允许接受本机的响应。</p>
<p><img src="/2023/02/02/redis/20211022133624.png" alt="20211022 133624"></p>
<p><em><strong>protected-mode</strong></em></p>
<p>将本机访问保护模式设置 <em><strong>no</strong></em>。</p>
<p><img src="/2023/02/02/redis/20211022133819.png" alt="20211022 133819"></p>
<p><em><strong>port</strong></em></p>
<p>端口号，默认 <em><strong>6379</strong></em>。</p>
<p><img src="/2023/02/02/redis/20211022133911.png" alt="20211022 133911"></p>
<p><em><strong>tcp-backlog</strong></em></p>
<p>设置 <em><strong>tcp</strong></em> 的 <em><strong>backlog</strong></em>，<em><strong>backlog</strong></em> 其实是一个连接队列，<em><strong>backlog</strong></em> 队列总和 $&#x3D;$ 未完成三次握手队列 $+$ 已经完成三次握手队列。</p>
<p>在高并发环境下你需要一个高 <em><strong>backlog</strong></em> 值来避免慢客户端连接问题。</p>
<p><img src="/2023/02/02/redis/20211022134622.png" alt="20211022 134622"></p>
<p><em><strong>timeout</strong></em></p>
<p>一个空闲的客户端维持多少秒会关闭，0 表示关闭该功能。即永不关闭。</p>
<p><img src="/2023/02/02/redis/20211022134726.png" alt="20211022 134726"></p>
<p><em><strong>tcp-keepalive</strong></em></p>
<p>对访问客户端的一种心跳检测，每个 <em><strong>n</strong></em> 秒检测一次。</p>
<p>单位为秒，如果设置为 0，则不会进行 <em><strong>Keepalive</strong></em> 检测，建议设置成 60。</p>
<p><img src="/2023/02/02/redis/20211022134806.png" alt="20211022 134806"></p>
</blockquote>
<h2 id="GENERAL"><a href="#GENERAL" class="headerlink" title="GENERAL"></a><em><strong>GENERAL</strong></em></h2><blockquote>
<p>通用。</p>
<p><em><strong>daemonize</strong></em></p>
<p>是否为后台进程，设置为 <em><strong>yes</strong></em>。</p>
<p>守护进程，后台启动。</p>
<p><img src="/2023/02/02/redis/20211022135016.png" alt="20211022 135016"></p>
<p><em><strong>pidfile</strong></em></p>
<p>存放 <em><strong>pid</strong></em> 文件的位置，每个实例会产生一个不同的 <em><strong>pid</strong></em> 文件。</p>
<p><img src="/2023/02/02/redis/20211022135110.png" alt="20211022 135110"></p>
<p><em><strong>loglevel</strong></em></p>
<p>指定日志记录级别，<em><strong>Redis</strong></em> 总共支持四个级别：<em><strong>debug、verbose、notice、warning</strong></em>，默认为 <em><strong>notice</strong></em>。</p>
<p><img src="/2023/02/02/redis/20211022135201.png" alt="20211022 135201"></p>
<p><em><strong>logfile</strong></em></p>
<p>日志文件名称。</p>
<p><img src="/2023/02/02/redis/20211022135228.png" alt="20211022 135228"></p>
<p><em><strong>database</strong></em></p>
<p>设定库的数量 默认16，默认数据库为 0，可以使用 <code>SELECT &lt;dbid&gt;</code> 命令在连接上指定数据库 <em><strong>id</strong></em>。</p>
<p><img src="/2023/02/02/redis/20211022135317.png" alt="20211022 135317"></p>
</blockquote>
<h2 id="SECURITY"><a href="#SECURITY" class="headerlink" title="SECURITY"></a><em><strong>SECURITY</strong></em></h2><blockquote>
<p>安全。</p>
<p>访问密码的查看、设置和取消。</p>
<p>在命令中设置密码，只是临时的。重启 <em><strong>redis</strong></em> 服务器，密码就还原了。</p>
<p>永久设置，需要在配置文件中进行设置。</p>
</blockquote>
<h2 id="LIMITS"><a href="#LIMITS" class="headerlink" title="LIMITS"></a><em><strong>LIMITS</strong></em></h2><blockquote>
<p>限制。</p>
<p><em><strong>maxclients</strong></em></p>
<p>设置 <em><strong>redis</strong></em> 同时可以与多少个客户端进行连接。</p>
<p>默认情况下为 <em><strong>10000</strong></em> 个客户端。</p>
<p>如果达到了此限制，<em><strong>redis</strong></em> 则会拒绝新的连接请求，并且向这些连接请求方发出 <em><strong>max number of clients reached</strong></em> 以作回应。</p>
<p><img src="/2023/02/02/redis/20211022140540.png" alt="20211022 140540"></p>
<p><em><strong>maxmemory</strong></em></p>
<p>建议<strong>必须设置</strong>，否则，将内存占满，造成服务器宕机。</p>
<p>设置 <em><strong>redis</strong></em> 可以使用的内存量。一旦到达内存使用上限，<em><strong>redis</strong></em> 将会试图移除内部数据，移除规则可以通过 <em><strong>maxmemory-policy</strong></em> 来指定。</p>
<p>如果 <em><strong>redis</strong></em> 无法根据移除规则来移除内存中的数据，或者设置了不允许移除，那么 <em><strong>redis</strong></em> 则会针对那些需要申请内存的指令返回错误信息，比如 <em><strong>SET、LPUSH</strong></em> 等。</p>
<p>但是对于无内存申请的指令，仍然会正常响应，比如 <em><strong>GET</strong></em> 等。如果你的 <em><strong>redis</strong></em> 是主 <em><strong>redis</strong></em>（ 说明你的 <em><strong>redis</strong></em> 有从 <em><strong>redis</strong></em> ），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</p>
<p><img src="/2023/02/02/redis/20211022140558.png" alt="20211022 140558"></p>
<p><em><strong>maxmemory-policy</strong></em></p>
<p><em><strong>volatile-lru</strong></em>：使用 <em><strong>LRU</strong></em> 算法移除 <em><strong>key</strong></em>，只对设置了过期时间的键（最近最少使用）。</p>
<p><em><strong>allkeys-lru</strong></em>：在所有集合 <em><strong>key</strong></em> 中，使用 <em><strong>LRU</strong></em> 算法移除 <em><strong>key</strong></em>。</p>
<p><em><strong>volatile-random</strong></em>：在过期集合中移除随机的 <em><strong>key</strong></em>，只对设置了过期时间的键。</p>
<p><em><strong>allkeys-random</strong></em>：在所有集合 <em><strong>key</strong></em> 中，移除随机的 <em><strong>key</strong></em>。</p>
<p><em><strong>volatile-ttl</strong></em>：移除那些 <em><strong>TTL</strong></em> 值最小的 <em><strong>key</strong></em>，即那些最近要过期的 <em><strong>key</strong></em>。</p>
<p><em><strong>noeviction</strong></em>：不进行移除。针对写操作，只是返回错误信息。</p>
<p><img src="/2023/02/02/redis/20211022140809.png" alt="20211022 140809"></p>
<p><em><strong>maxmemory-samples</strong></em></p>
<p>设置样本数量，<em><strong>LRU</strong></em> 算法和最小 <em><strong>TTL</strong></em> 算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，<em><strong>redis</strong></em> 默认会检查这么多个 <em><strong>key</strong></em> 并选择其中 <em><strong>LRU</strong></em> 的那个。</p>
<p>一般设置 3 到 7 的数字，数值越小样本越不准确，但性能消耗越小。</p>
<p><img src="/2023/02/02/redis/20211022140911.png" alt="20211022 140911"></p>
</blockquote>
<h1 id="常用五大基本数据类型"><a href="#常用五大基本数据类型" class="headerlink" title="常用五大基本数据类型"></a>常用五大基本数据类型</h1><h2 id="key操作"><a href="#key操作" class="headerlink" title="key操作"></a>key操作</h2><blockquote>
<p><code>keys *</code>：查看当前库所有 <em><strong>key</strong></em>  </p>
<p><code>exists key</code>：判断某个 <em><strong>key</strong></em> 是否存在</p>
<p><code>type key</code>：查看你的 <em><strong>key</strong></em> 是什么类型</p>
<p><code>del key</code> ：删除指定的 <em><strong>key</strong></em> 数据</p>
<p><code>unlink key</code>：根据 <em><strong>value</strong></em> 选择非阻塞删除，仅将 <em><strong>keys</strong></em> 从 <em><strong>keyspace</strong></em> 元数据中删除，真正的删除会在后续异步操作</p>
<p><code>expire key 10</code> ：为给定的 <em><strong>key</strong></em> 设置过期时间</p>
<p><code>ttl key</code>：查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>
<p><code>select</code>：命令切换数据库</p>
<p><code>dbsize</code>：查看当前数据库的 <em><strong>key</strong></em> 的数量</p>
<p><code>flushdb</code>：清空当前库</p>
<p><code>flushall</code>：通杀全部库</p>
</blockquote>
<h2 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h2><p><em><strong>String</strong></em> 类型是二进制安全的。意味着 <em><strong>Redis</strong></em> 的 <em><strong>string</strong></em> 可以包含任何数据。比如 <em><strong>jpg</strong></em> 图片或者序列化的对象。</p>
<p><em><strong>String</strong></em> 类型是 <em><strong>Redis</strong></em> 最基本的数据类型，一个 <em><strong>Redis</strong></em> 中字符串 <em><strong>value</strong></em> 最多可以是 512M。</p>
<blockquote>
<p><code>set &lt;key&gt;&lt;value&gt;</code>：添加键值对</p>
<p><code>get &lt;key&gt;</code>：查询对应键值</p>
<p><code>append &lt;key&gt;&lt;value&gt;</code>：将给定的 <em><strong>&lt;value&gt;</strong></em> 追加到原值的末尾</p>
<p><code>strlen &lt;key&gt;</code>：获得值的长度</p>
<p><code>setnx &lt;key&gt;&lt;value&gt;</code>：只有在 <em><strong>key</strong></em> 不存在时，设置 <em><strong>key</strong></em> 的值</p>
<p><code>incr &lt;key&gt;</code>：将 <em><strong>key</strong></em> 中储存的数字值增 1，只能对数字值操作，如果为空，新增值为 1（**<u>具有原子性</u>**）</p>
<p><code>decr &lt;key&gt;</code>：将 <em><strong>key</strong></em> 中储存的数字值减 1，只能对数字值操作，如果为空，新增值为 -1</p>
<p><code>incrby/decrby &lt;key&gt;&lt;步长&gt;</code>：将 <em><strong>key</strong></em> 中储存的数字值增减。自定义步长</p>
<p><code>mset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;</code> ：同时设置一个或多个 <em><strong>key-value</strong></em> 对 </p>
<p><code>mget &lt;key1&gt;&lt;key2&gt;&lt;key3&gt;...</code>：同时获取一个或多个 <em><strong>value</strong></em> </p>
<p><code>msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;... </code>：同时设置一个或多个 <em><strong>key-value</strong></em> 对，当且仅当所有给定 <em><strong>key</strong></em> 都不存在	</p>
<p><code>getrange &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;</code>：获得值的范围</p>
<p><code>setrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;</code>：用 <em><strong>&lt;value&gt;</strong></em> 覆写 <em><strong>&lt;key&gt;</strong></em> 所储存的字符串值</p>
<p><code>setex &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;</code>：设置键值的同时，设置过期时间，单位秒。</p>
<p><code>getset &lt;key&gt;&lt;value&gt;</code>：以新换旧，设置了新值同时获得旧值。</p>
</blockquote>
<p><strong>原子性</strong></p>
<p>所谓 <strong>原子</strong> 操作是指不会被线程调度机制打断的操作；</p>
<p>这种操作一旦开始，就一直运行到结束，中间不会有任何 <em><strong>context switch</strong></em> （切换到另一个线程）。</p>
<ul>
<li><p>在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。</p>
</li>
<li><p>在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</p>
</li>
</ul>
<p><em><strong>Redis</strong></em> 单命令的原子性主要得益于 <em><strong>Redis</strong></em> 的单线程。</p>
<p><strong>数据结构</strong></p>
<p>内部结构实现上类似于 <em><strong>Java</strong></em> 的 <em><strong>ArrayList</strong></em>，采用预分配冗余空间的方式来减少内存的频繁分配.</p>
<p><img src="/2023/02/02/redis/20211022000751746.png" alt="20211022000751746"></p>
<h2 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h2><p><em><strong>Redis</strong></em> 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p>
<p><img src="/2023/02/02/redis/20211022121129201.png" alt="20211022121129201"></p>
<blockquote>
<p><code>lpush/rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; ....</code>： 从左边&#x2F;右边插入一个或多个值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpush k1 v1 v2 v3</span><br><span class="line">lrange k1 0 -1</span><br><span class="line">输出：v3 v2 v1</span><br><span class="line"></span><br><span class="line">rpush k1 v1 v2 v3</span><br><span class="line">rrange k1 0 -1</span><br><span class="line">输出：v1 v2 v3</span><br></pre></td></tr></table></figure>

<p><code>lpop/rpop &lt;key&gt;</code>：从左边&#x2F;右边吐出一个值。值在键在，值光键亡。</p>
<p><code>rpoplpush &lt;key1&gt;&lt;key2&gt;</code>：从 <em><strong>&lt;key1&gt;</strong></em> 列表右边吐出一个值，插到 <em><strong>&lt;key2&gt;</strong></em> 列表左边。</p>
<p><code>lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;</code>：按照索引下标获得元素（从左到右）</p>
<p><code>lrange mylist 0 -1  0</code>：左边第一个，-1右边第一个，（0 -1表示获取所有）</p>
<p><code>lindex &lt;key&gt;&lt;index&gt;</code>：按照索引下标获得元素（从左到右）</p>
<p><code>llen &lt;key&gt;</code>：获得列表长度  </p>
<p><code>linsert &lt;key&gt; before/after &lt;value&gt;&lt;newvalue&gt;</code>：在 <em><strong>&lt;value&gt;</strong></em> 的前面&#x2F;后面插入 <em><strong>&lt;newvalue&gt;</strong></em> 插入值</p>
<p><code>lrem &lt;key&gt;&lt;n&gt;&lt;value&gt;</code>：从左边删除 <em><strong>n</strong></em> 个 <em><strong>value</strong></em>（从左到右）</p>
<p><code>lset&lt;key&gt;&lt;index&gt;&lt;value&gt;</code>：将列表 <em><strong>key</strong></em> 下标为 <em><strong>index</strong></em> 的值替换成 <em><strong>value</strong></em></p>
</blockquote>
<p><strong>数据结构</strong></p>
<p><em><strong>List</strong></em> 的数据结构为快速链表 <em><strong>quickList</strong></em>。</p>
<p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 <em><strong>ziplist</strong></em>，也即是压缩列表。</p>
<p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p>
<p>当数据量比较多的时候才会改成 <em><strong>quicklist</strong></em>。</p>
<p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是 <em><strong>int</strong></em> 类型的数据，结构上还需要两个额外的指针 <em><strong>prev</strong></em> 和 <em><strong>next</strong></em>。</p>
<p><em><strong>Redis</strong></em> 将链表和 <em><strong>ziplist</strong></em> 结合起来组成了 <em><strong>quicklist</strong></em>。也就是将多个 <em><strong>ziplist</strong></em> 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>
<p><img src="/2023/02/02/redis/20211022122514593.png" alt="20211022122514593"></p>
<h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p><em><strong>Set</strong></em> 对外提供的功能与 <em><strong>List</strong></em> 类似列表的功能，特殊之处在于 <em><strong>Set</strong></em> 是可以 <strong><u>自动排重</u></strong> 的，当需要存储一个列表数据，又不希望出现重复数据时，<em><strong>Set</strong></em> 是一个很好的选择，并且 <em><strong>Set</strong></em> 提供了判断某个成员是否在一个 <em><strong>Set</strong></em> 集合内的重要接口，这个也是 <em><strong>List</strong></em> 所不能提供的。</p>
<p><em><strong>Redis</strong></em> 的 <em><strong>Set</strong></em> 是 <em><strong>String</strong></em> 类型的无序集合。它底层其实是一个 <em><strong>value</strong></em> 为 <em><strong>null</strong></em> 的 <em><strong>hash</strong></em> 表，所以添加，删除，查找的复杂度都是 ***O(1)***。</p>
<p>一个算法，随着数据的增加，执行时间的长短，如果是 ***O(1)***，数据增加，查找数据的时间不变。</p>
<blockquote>
<p><code>sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ..... </code>：将一个或多个 <em><strong>member</strong></em> 元素加入到集合 <em><strong>key</strong></em> 中，已经存在的 <em><strong>member</strong></em> 元素将被忽略</p>
<p><code>smembers &lt;key&gt;</code>：取出该集合的所有值。</p>
<p><code>sismember &lt;key&gt;&lt;value&gt;</code>：判断集合 <em><strong>&lt;key&gt;</strong></em> 是否为含有该 <em><strong>&lt;value&gt;</strong></em> 值，有返回 1，没有返回 0</p>
<p><code>scard&lt;key&gt;</code>：返回该集合的元素个数。</p>
<p><code>srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ....</code>：删除集合中的某个元素</p>
<p><code>spop &lt;key&gt;</code>：随机从该集合中吐出一个值</p>
<p><code>srandmember &lt;key&gt;&lt;n&gt;</code>：随机从该集合中取出 <em><strong>n</strong></em> 个值，不会从集合中删除 </p>
<p><code>smove &lt;source&gt;&lt;destination&gt;value</code>：把集合中一个值从一个集合移动到另一个集合</p>
<p><code>sinter &lt;key1&gt;&lt;key2&gt;</code>：返回两个集合的交集元素</p>
<p><code>sunion &lt;key1&gt;&lt;key2&gt;</code>：返回两个集合的并集元素</p>
<p><code>sdiff &lt;key1&gt;&lt;key2&gt;</code>：返回两个集合的差集元素（<em><strong>key1</strong></em> 中的，不包含 <em><strong>key2</strong></em> 中的）</p>
</blockquote>
<p><strong>数据结构</strong></p>
<p><em><strong>Set</strong></em> 数据结构是字典，字典是用哈希表实现的。</p>
<h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><p><em><strong>Redis hash</strong></em> 是一个键值对集合。</p>
<p><em><strong>Redis hash</strong></em> 是一个 <em><strong>String</strong></em> 类型的 <em><strong>field</strong></em> 和 <em><strong>value</strong></em> 的映射表，<em><strong>hash</strong></em> 特别适合用于存储对象。</p>
<blockquote>
<p><code>hset &lt;key&gt;&lt;field&gt;&lt;value&gt;</code>：给 <em><strong>&lt;key&gt;</strong></em> 集合中的 <em><strong>&lt;field&gt;</strong></em> 键赋值 <em><strong>&lt;value&gt;</strong></em></p>
<p><code>hget &lt;key1&gt;&lt;field&gt;</code>：从 <em><strong>&lt;key1&gt;</strong></em> 集合 <em><strong>&lt;field&gt;</strong></em> 取出 <em><strong>value</strong></em> </p>
<p><code>hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;...</code>： 批量设置 <em><strong>hash</strong></em> 的值</p>
<p><code>hexists &lt;key1&gt;&lt;field&gt;</code>：查看哈希表 <em><strong>key</strong></em> 中，给定域 <em><strong>field</strong></em> 是否存在</p>
<p><code>hkeys &lt;key&gt;</code>：列出该 <em><strong>hash</strong></em> 集合的所有 <em><strong>field</strong></em></p>
<p><code>hvals &lt;key&gt;</code>：列出该 <em><strong>hash</strong></em> 集合的所有 <em><strong>value</strong></em></p>
<p><code>hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;</code>：为哈希表 <em><strong>key</strong></em> 中的域 <em><strong>field</strong></em> 的值加上增量 1  -1</p>
<p><code>hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;</code>：将哈希表 <em><strong>key</strong></em> 中的域 <em><strong>field</strong></em> 的值设置为 <em><strong>value</strong></em> ，当且仅当域 <em><strong>field</strong></em> 不存在</p>
</blockquote>
<p><strong>数据结构</strong></p>
<p><em><strong>Hash</strong></em> 类型对应的数据结构是两种：<em><strong>ziplist</strong></em>（压缩列表），<em><strong>hashtable</strong></em>（哈希表）。</p>
<p>当 <em><strong>field-value</strong></em> 长度较短且个数较少时，使用 <em><strong>ziplist</strong></em>，否则使用 <em><strong>hashtable</strong></em>。</p>
<h2 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h2><p><em><strong>Redis</strong></em> 有序集合 <em><strong>zset</strong></em> 与普通集合 <em><strong>set</strong></em> 非常相似，是一个没有重复元素的字符串集合。</p>
<p>不同之处是有序集合的每个成员都关联了一个评分（<em><strong>score</strong></em>）,这个评分（<em><strong>score</strong></em>）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复的。</p>
<p>因为元素是有序的，所以可以很快的根据评分（<em><strong>score</strong></em>）或者次序（<em><strong>position</strong></em>）来获取一个范围的元素。</p>
<p>访问有序集合的中间元素也是非常快的，因此能够使用有序集合作为一个没有重复成员的智能列表。</p>
<blockquote>
<p><code>zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;…</code>：将一个或多个 <em><strong>member</strong></em> 元素及其 <em><strong>score</strong></em> 值加入到有序集 <em><strong>key</strong></em> 当中</p>
<p><code>zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt; [WITHSCORES]  </code>：返回有序集 <em><strong>key</strong></em> 中，下标在 <em><strong>&lt;start&gt;&lt;stop&gt;</strong></em> 之间的元素</p>
<p>当带 <em><strong>WITHSCORES</strong></em>，可以让分数一起和值返回到结果集</p>
<p><code>zrangebyscore key min max [withscores] [limit offset count]</code>：返回有序集 <em><strong>key</strong></em> 中，所有 <em><strong>score</strong></em> 值介于 <em><strong>min</strong></em> 和 <em><strong>max</strong></em> 之间（包括等于 <em><strong>min</strong></em> 或 <em><strong>max</strong></em> ）的成员。有序集成员按 <em><strong>score</strong></em> 值递增（从小到大）次序排列。</p>
<p><code>zrevrangebyscore key max min [withscores] [limit offset count] </code>：同上，改为从大到小排列</p>
<p><code>zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;</code>：为元素的 <em><strong>score</strong></em> 加上增量</p>
<p><code>zrem &lt;key&gt;&lt;value&gt;</code>：删除该集合下，指定值的元素</p>
<p><code>zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;</code>：统计该集合，分数区间内的元素个数 </p>
<p><code>zrank &lt;key&gt;&lt;value&gt;</code>：返回该值在集合中的排名，从 0 开始。</p>
</blockquote>
<p><strong>数据结构</strong></p>
<p><em><strong>SortedSet（zset）</strong></em>是 <em><strong>Redis</strong></em> 提供的一个非常特别的数据结构，一方面它等价于 <em><strong>Java</strong></em> 的数据结构 ***Map&lt;String, Double&gt;***，可以给每一个元素 <em><strong>value</strong></em> 赋予一个权重 <em><strong>score</strong></em>，另一方面它又类似于 <em><strong>TreeSet</strong></em>，内部的元素会按照权重 <em><strong>score</strong></em> 进行排序，可以得到每个元素的名次，还可以通过 <em><strong>score</strong></em> 的范围来获取元素的列表。</p>
<p><em><strong>zset</strong></em> 底层使用了两个数据结构</p>
<ul>
<li><p><em><strong>hash</strong></em>，<em><strong>hash</strong></em> 的作用就是关联元素 <em><strong>value</strong></em> 和权重 <em><strong>score</strong></em>，保障元素 <em><strong>value</strong></em> 的唯一性，可以通过元素 <em><strong>value</strong></em> 找到相应的 <em><strong>score</strong></em> 值</p>
</li>
<li><p>跳跃表，跳跃表的目的在于给元素 <em><strong>value</strong></em> 排序，根据 <em><strong>score</strong></em> 的范围获取元素列表</p>
</li>
</ul>
<h1 id="Redis6新数据结构"><a href="#Redis6新数据结构" class="headerlink" title="Redis6新数据结构"></a>Redis6新数据结构</h1><p>$###################\space to \space do\space ###################$</p>
<h1 id="Redis的发布与订阅"><a href="#Redis的发布与订阅" class="headerlink" title="Redis的发布与订阅"></a>Redis的发布与订阅</h1><p><em><strong>Redis</strong></em> 发布订阅（ <em><strong>pub&#x2F;sub</strong></em> ）是一种消息通信模式：发送者（ <em><strong>pub</strong></em> ）发送消息，订阅者（ <em><strong>sub</strong></em> ）接收消息。</p>
<p><em><strong>Redis</strong></em> 客户端可以订阅任意数量的频道。</p>
<ol>
<li>客户端可以订阅频道</li>
</ol>
<p><img src="/2023/02/02/redis/20211022141802.png" alt="20211022 141802"></p>
<ol start="2">
<li>当给这个频道发布消息后，消息就会发送给订阅的客户端</li>
</ol>
<p><img src="/2023/02/02/redis/20211022142140.png" alt="20211022 142140"></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subscribe channel # 订阅频道</span><br><span class="line"></span><br><span class="line">publish channel hello # 频道发送信息</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="事务和锁机制"><a href="#事务和锁机制" class="headerlink" title="事务和锁机制"></a>事务和锁机制</h1><p><em><strong>Redis</strong></em> 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p><em><strong>Redis</strong></em> 事务的主要作用就是串联多个命令防止别的命令插队。</p>
<h2 id="Multi、Exec、Discard"><a href="#Multi、Exec、Discard" class="headerlink" title="Multi、Exec、Discard"></a><em>Multi</em>、<em>Exec</em>、<em>Discard</em></h2><img src="/Users/nanase/Library/Application Support/typora-user-images/截屏2021-10-27 18.12.45.png" style="zoom:50%;">

<blockquote>
<p><em><strong>Multi</strong></em></p>
<p><em><strong>Exec</strong></em></p>
<p><em><strong>Discard</strong></em>	</p>
<p>从输入 <em><strong>Multi</strong></em> 命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入 <em><strong>Exec</strong></em> 后，<em><strong>Redis</strong></em> 会将之前的命令队列中的命令依次执行。</p>
<p>组队的过程中可以通过 <em><strong>Discard</strong></em> 来放弃组队。 </p>
</blockquote>
<ul>
<li><p>组队成功，提交成功</p>
<p><img src="/2023/02/02/redis/20211027182354.png" alt="20211027 182354"></p>
</li>
<li><p>放弃组队</p>
<p><img src="/2023/02/02/redis/20211027182606.png" alt="20211027 182606"></p>
</li>
<li><p>组队中有命令错误，不会执行</p>
<p><img src="/2023/02/02/redis/20211027182950.png" alt="20211027 182950"></p>
</li>
<li><p>组队中不报错，执行时报错</p>
<p><img src="/2023/02/02/redis/20211027183115.png" alt="20211027 183115"></p>
</li>
</ul>
<p>当组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>悲观锁（<em><strong>Pessimistic Lock</strong></em>），即每次去拿数据的时候都认为有其他线程会修改，所以每次在拿数据的时候都会上锁，这样其他线程想要拿到这个数据就会被 <em><strong>block</strong></em> 直到成功拿到锁。（效率低）</p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁（<em><strong>Optimistic Lock</strong></em>），即每次去拿数据的时候都认为其他线程不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间有没有其他线程去更新这个数据，可以使用版本号等机制。</p>
<p><strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。</p>
<p><em><strong>Redis</strong></em> 就是利用这种 <em><strong>check-and-set</strong></em> 机制实现事务的。</p>
<h2 id="Watch、unwatch"><a href="#Watch、unwatch" class="headerlink" title="Watch、unwatch"></a><em>Watch、unwatch</em></h2><p>在执行 <em><strong>multi</strong></em> 之前，先执行 <em><strong>watch key1 [key2]<em><strong>，可以监视一个（或多个 ）</strong></em>key</strong></em> 。如果在事务执行之前这个 <em><strong>key</strong></em> 被其他命令所改动，那么事务将被打断。</p>
<p>取消 <em><strong>WATCH</strong></em> 命令对所有 <em><strong>key</strong></em> 的监视。如果在执行 <em><strong>WATCH</strong></em> 命令之后，<em><strong>EXEC</strong></em> 命令或 <em><strong>DISCARD</strong></em> 命令先被执行，那么就不需要再执行 <em><strong>UNWATCH</strong></em> 。</p>
<h2 id="事务三特性"><a href="#事务三特性" class="headerlink" title="事务三特性"></a>事务三特性</h2><ul>
<li><p>单独的隔离操作 </p>
<p>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 </p>
</li>
<li><p>没有隔离级别的概念 </p>
<p>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行。</p>
</li>
<li><p>不保证原子性 </p>
<p>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 。</p>
</li>
</ul>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>在指定的时间间隔内将内存中的数据集快照写入磁盘， 即 <em><strong>Snapshot</strong></em> 快照，恢复时是将快照文件直接读到内存里。</p>
<p><img src="/2023/02/02/redis/20211027203149.png" alt="20211027 203149"></p>
<p><em><strong>Redis</strong></em> 会单独创建一个子进程（<em><strong>fork</strong></em>）来进行持久化。</p>
<p>先将数据写入到一个临时文件中，待持久化过程完成后，再将这个临时文件内容覆盖到 <em><strong>dump.rdb</strong></em>。 </p>
<p>整个过程中，主进程是不进行任何 <em><strong>IO</strong></em> 操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 <em><strong>RDB</strong></em> 方式要比 <em><strong>AOF</strong></em> 方式更加的高效。</p>
<p><strong><em>RDB</em> 的缺点是最后一次持久化后的数据可能丢失</strong>。</p>
<h3 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h3><ul>
<li><p>作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p>
</li>
<li><p>在 <em><strong>Linux</strong></em> 程序中，<em><strong>fork()</strong></em> 会产生一个和父进程完全相同的子进程，但子进程在此后多会 <em><strong>exec</strong></em> 系统调用，出于效率考虑，<em><strong>Linux</strong></em> 中引入了 <strong>写时复制技术</strong></p>
</li>
<li><p><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程</p>
</li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><blockquote>
<p><strong><em>dump</em> 文件名字</strong></p>
<p>在 <em><strong>redis.conf</strong></em> 中配置文件名称，默认为 <em><strong>dump.rdb</strong></em>。</p>
<p><img src="/2023/02/02/redis/20211027204143.png" alt="20211027 204143"></p>
<p><strong><em>dump</em> 保存位置</strong></p>
<p><em><strong>rdb</strong></em> 文件的保存路径可以修改。默认为 <em><strong>Redis</strong></em> 启动时命令行所在的目录下。</p>
<p><img src="/2023/02/02/redis/20211027204209.png" alt="20211027 204209"></p>
<p><em><strong>stop-writes-on-bgsave-error</strong></em></p>
<p>即当 <em><strong>redis</strong></em> 无法写入磁盘，关闭 <em><strong>redis</strong></em> 的写入操作。</p>
<p><img src="/2023/02/02/redis/20211030133016.png" alt="20211030 133016"></p>
<p><em><strong>rdbcompression</strong></em></p>
<p>持久化的文件是否进行压缩存储。</p>
<p><img src="/2023/02/02/redis/20211030133134.png" alt="20211030 133134"></p>
<p><em><strong>rdbchecksum</strong></em></p>
<p>完整性的检查，即数据是否完整性、准确性。</p>
<p><img src="/2023/02/02/redis/20211030133228.png" alt="20211030 133228"></p>
<p><em><strong>save</strong></em></p>
<p>表示写操作的次数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：save 秒 写操作次数</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/02/redis/20211030133342.png" alt="20211030 133342"></p>
</blockquote>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>适合大规模的数据恢复；</li>
<li>对数据完整性和一致性要求不高更适合使用；</li>
<li>节省磁盘空间；</li>
<li>恢复速度快。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><em><strong>Fork</strong></em> 的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑；</li>
<li>虽然 <em><strong>Redis</strong></em> 在 <em><strong>fork</strong></em> 时使用了<strong>写时拷贝技术</strong>，但是如果数据庞大时还是比较消耗性能；</li>
<li>在备份周期在一定间隔时间做一次备份，所以如果 <em><strong>Redis</strong></em> 意外 <em><strong>down</strong></em> 掉的话，就会丢失最后一次快照后的所有修改。</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>以日志的形式来记录每个写操作（增量保存），将 <em><strong>Redis</strong></em> 执行过的所有写指令记录下来（读操作不记录）， <u>只许追加文件但不可以改写文件</u>，<em><strong>Redis</strong></em> 启动之初会读取该文件重新构建数据，换言之，如果 <em><strong>Redis</strong></em> 重启就会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
<p><strong>执行流程</strong></p>
<ul>
<li><p>客户端的请求写命令会被 <em><strong>append</strong></em> 追加到 <em><strong>AOF</strong></em> 缓冲区内；</p>
</li>
<li><p><em><strong>AOF</strong></em> 缓冲区根据 <em><strong>AOF</strong></em> 持久化策略 <code>[always,everysec,no]</code> 将操作 <em><strong>sync</strong></em> 同步到磁盘的 <em><strong>AOF</strong></em> 文件中；</p>
</li>
<li><p><em><strong>AOF</strong></em> 文件大小超过重写策略或手动重写时，会对 <em><strong>AOF</strong></em> 文件 <em><strong>Rewrite</strong></em> 重写，压缩 <em><strong>AOF</strong></em> 文件容量；</p>
</li>
<li><p><em><strong>Redis</strong></em> 服务重启时，会重新 <em><strong>load</strong></em> 加载 <em><strong>AOF</strong></em> 文件中的写操作达到数据恢复的目的。</p>
</li>
</ul>
<p><em><strong>AOF</strong></em> 和 <em><strong>RDB</strong></em> 同时开启时，系统默认读取 <em><strong>AOF</strong></em> 的数据（数据不会存在丢失）</p>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><blockquote>
<p><strong><em>AOF</em> 默认不开启</strong> </p>
<p><img src="/2023/02/02/redis/20211030134924.png" alt="20211030 134924"></p>
<p><strong>文件名字</strong></p>
<p><img src="/2023/02/02/redis/20211030134959.png" alt="20211030 134959"></p>
<p><strong><em>AOF</em> 同步频率设置</strong></p>
<p><img src="/2023/02/02/redis/20211030135807.png" alt="20211030 135807"></p>
<p><em><strong>appendfsync always</strong></em></p>
<p>​	始终同步，每次 <em><strong>Redis</strong></em> 的写入都会立刻记入日志；</p>
<p>​	性能较差但数据完整性比较好。</p>
<p><em><strong>appendfsync everysec</strong></em></p>
<p>​	每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</p>
<p><em><strong>appendfsync no</strong></em></p>
<p>​	<em><strong>Redis</strong></em> 不主动进行同步，把同步时机交给操作系统。</p>
<p><strong><em>Rewrite</em> 压缩</strong></p>
<p>当 <em><strong>AOF</strong></em> 文件的大小超过所设定的阈值时，<em><strong>Redis</strong></em> 就会启动 <em><strong>AOF</strong></em> 文件的内容压缩，只保留可以恢复数据的最小指令集。可以使用命令 <em><strong>bgrewriteaof</strong></em>。</p>
<p><img src="/2023/02/02/redis/20211030140203.png" alt="20211030 140203"></p>
</blockquote>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>备份机制更稳健，丢失数据概率更低；</li>
<li>可读的日志文本，通过操作 <em><strong>AOF</strong></em> 稳健，可以处理误操作。</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>比起 <em><strong>RDB</strong></em> 占用更多的磁盘空间；</li>
<li>恢复备份速度要慢；</li>
<li>每次读写都同步的话，有一定的性能压力；</li>
<li>存在个别 <em><strong>Bug</strong></em>，造成不能恢复。</li>
</ul>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><blockquote>
<p>官方推荐两个都启用。</p>
<p>如果对数据不敏感，可以选单独用 <em><strong>RDB</strong></em>。</p>
<p>不建议单独用 <em><strong>AOF</strong></em>，因为可能会出现 <em><strong>Bug</strong></em>。</p>
<p>如果只是做纯内存缓存，可以都不用。</p>
</blockquote>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>主机数据更新后根据配置和策略， 自动同步到备机的 <em><strong>master&#x2F;slaver</strong></em> 机制，<em><strong>Master</strong></em> 以写为主，<em><strong>Slaver</strong></em> 以读为主。</p>
<p><img src="/2023/02/02/redis/20211030141236.png" alt="20211030 141236"></p>
<ol>
<li>读写分离，性能扩展</li>
<li>容灾快速恢复</li>
<li>一主多从！</li>
</ol>
<h2 id="搭建一主两从"><a href="#搭建一主两从" class="headerlink" title="搭建一主两从"></a>搭建一主两从</h2><ol>
<li>创建文件目录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/opt/etc</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将 <em><strong>redis.conf</strong></em> 复制到当前目录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /etc/redis.conf /opt/etc/</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建 3 个 <em><strong>redis.conf</strong></em> 配置文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis6379.conf</span><br><span class="line">redis6380.conf</span><br><span class="line">redis6381.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># redis6379.conf</span></span><br><span class="line">include /opt/etc/redis.conf</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line">port 6379</span><br><span class="line">dbfilename dump6379.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># redis6380.conf</span></span><br><span class="line">include /opt/etc/redis.conf</span><br><span class="line">pidfile /var/run/redis_6380.pid</span><br><span class="line">port 6380</span><br><span class="line">dbfilename dump6380.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># redis6381.conf</span></span><br><span class="line">include /opt/etc/redis.conf</span><br><span class="line">pidfile /var/run/redis_6381.pid</span><br><span class="line">port 6381</span><br><span class="line">dbfilename dump6381.rdb</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>启动 3 台 <em><strong>redis</strong></em> 服务器</li>
</ol>
<p><img src="/2023/02/02/redis/20211030145737.png" alt="20211030 145737"></p>
<ol start="5">
<li>查看主机运行情况</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info replication</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/02/redis/20211030150010.png" alt="20211030 150010"></p>
<ol start="6">
<li>配从不配主</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">slaveof  &lt;ip&gt;&lt;port&gt;</span><br><span class="line"><span class="comment"># 成为某个实例的从服务器</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/02/redis/20211030150322.png" alt="20211030 150322"></p>
<p><img src="/2023/02/02/redis/20211030150340.png" alt="20211030 150340"></p>
<ol start="7">
<li>再次查看主机运行情况</li>
</ol>
<p><img src="/2023/02/02/redis/20211030150441.png" alt="20211030 150441"></p>
<p>成功搭建。</p>
<h2 id="一主二仆"><a href="#一主二仆" class="headerlink" title="一主二仆"></a>一主二仆</h2><blockquote>
<p>主机 <em><strong>6379</strong></em>，从机 <em><strong>6380</strong></em> 和 <em><strong>6381</strong></em>。</p>
<ol>
<li>假设从机 <em><strong>6380</strong></em> 挂掉。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当6380重启后，6380不再是6379的从机，而是作为新的master；</span><br><span class="line">当再次把6380作为6379的从机加入后，从机会把数据从头到尾复制。</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>假设主机 <em><strong>6379</strong></em> 挂掉。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6380和6381仍然是6379的从机，不会做任何事；</span><br><span class="line">当6379重启后，既然是主服务器。</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h2><p><img src="/2023/02/02/redis/20211030163815.png" alt="20211030 163815"></p>
<p>上一个 <em><strong>slave</strong></em> 可以是下一个 <em><strong>slave</strong></em> 的 <em><strong>master</strong></em>，<em><strong>slave</strong></em> 同样可以接收其他 <em><strong>slave</strong></em>的连接和同步请求，那么该 <em><strong>slave</strong></em> 作为了链条中下一个的 <em><strong>master</strong></em>，可以有效减轻 <em><strong>master</strong></em> 的写压力，去中心化降低风险。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slaveof &lt;ip&gt;&lt;port&gt;</span><br></pre></td></tr></table></figure>

<p>中途变更转向：会清除之前的数据，重新建立拷贝最新的。</p>
<p>当某个 <em><strong>slave</strong></em> 宕机，后面的 <em><strong>slave</strong></em> 都没法备份。</p>
<p>即当主机挂掉，从机还是从机，但是无法继续写数据。</p>
<h2 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h2><p>当一个 <em><strong>master</strong></em> 宕机后，后面的 <em><strong>slave</strong></em> 可以立刻升为 <em><strong>master</strong></em>，其后面的 <em><strong>slave</strong></em> 不用做任何修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slaveof no one</span><br></pre></td></tr></table></figure>



<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p><strong>反客为主的自动版</strong>，即能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p>
<ol>
<li>创建 <em><strong>sentinel.conf</strong></em> 文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/opt/etc/sentinel.conf</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置哨兵</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sentinel monitor mymaster 172.16.88.168 6379 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># mymaster：监控对象起的服务器名称</span></span><br><span class="line"><span class="comment"># 1：至少有多少个哨兵同意迁移的数量。 </span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动哨兵</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-sentinel  /opt/etc/sentinel.conf </span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/02/redis/20211030165308.png" alt="20211030 165308"></p>
<p>主机挂掉，会从机选举中产生新的主机。选举的规则。</p>
<h3 id="选举规则"><a href="#选举规则" class="headerlink" title="选举规则"></a>选举规则</h3><ul>
<li><p>根据优先级别，<em><strong>slave-priority&#x2F;replica-priority</strong></em>，优先选择优先级靠前的。</p>
<p><img src="/2023/02/02/redis/20211030170250.png" alt="20211030 170250"></p>
</li>
<li><p>根据偏移量，优先选择偏移量大的。</p>
</li>
<li><p>根据 <em><strong>runid</strong></em>，优先选择最小的服务。</p>
</li>
</ul>
<h3 id="复制延时"><a href="#复制延时" class="headerlink" title="复制延时"></a>复制延时</h3><p>由于所有的写操作都是先在 <em><strong>master</strong></em> 上操作，然后同步更新到 <em><strong>slave</strong></em> 上，所以从 <em><strong>master</strong></em> 同步到 <em><strong>slave</strong></em> 从机有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，<em><strong>slave</strong></em> 机器数量的增加也会使这个问题更加严重。</p>
<h2 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h2><ul>
<li><p><em><strong>slave</strong></em> 启动成功连接到 <em><strong>master</strong></em> 后会发送一个 <em><strong>sync</strong></em> 命令（同步命令）。</p>
</li>
<li><p><em><strong>master</strong></em> 接到命令启动后台的存盘进程，对数据进行持久化操作，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，<em><strong>master</strong></em> 将传送整个数据文件（<em><strong>rdb</strong></em>）到 <em><strong>slave</strong></em>，以完成一次完全同步。</p>
</li>
<li><p>当主服务进行写操作后，和从服务器进行数据同步。</p>
</li>
<li><p>全量复制：而 <em><strong>slave</strong></em> 服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p>
</li>
<li><p>增量复制：<em><strong>master</strong></em> 继续将新的所有收集到的修改命令依次传给 <em><strong>slave</strong></em>，完成同步。</p>
</li>
<li><p>只要是重新连接 <em><strong>master</strong></em>，一次完全同步（全量复制）将被自动执行。</p>
</li>
</ul>
<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>容量不够，<em><strong>redis</strong></em> 如何进行扩容？</p>
<p>并发写操作， <em><strong>redis</strong></em> 如何分摊？</p>
<p>主从模式，薪火相传模式，主机宕机，导致 <em><strong>ip</strong></em> 地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</p>
<p>解决方法：</p>
<ul>
<li><p>代理主机（ <em><strong>之前</strong></em> ）</p>
<p><img src="/2023/02/02/redis/20211030171915.png" alt="20211030 171915"></p>
</li>
<li><p>无中心化集群配置（ <em><strong>redis3.0</strong></em> ）</p>
</li>
</ul>
<p><img src="/2023/02/02/redis/20211030172146.png" alt="20211030 172146"></p>
<p><em><strong>Redis</strong></em> 集群实现了对 <em><strong>Redis</strong></em> 的水平扩容，即启动 <em><strong>N</strong></em> 个 <em><strong>Redis</strong></em> 节点，将整个数据库分布存储在这 <em><strong>N</strong></em> 个节点中，每个节点存储总数据的 <em><strong>1&#x2F;N</strong></em> 。</p>
<p><em><strong>Redis</strong></em> 集群通过分区（<em><strong>partition</strong></em>）来提供一定程度的可用性（<em><strong>availability</strong></em>），即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p>
<h2 id="搭建-Redis-集群"><a href="#搭建-Redis-集群" class="headerlink" title="搭建 Redis 集群"></a>搭建 <em>Redis</em> 集群</h2><ol>
<li>创建配置文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以redis6379.conf为例</span></span><br><span class="line">include /opt/etc/redis.conf</span><br><span class="line">pidfile /var/run/redis_6379.pid <span class="comment"># 更改</span></span><br><span class="line">port 6379 <span class="comment"># 更改</span></span><br><span class="line">dbfilename dump6379.rdb <span class="comment"># 更改</span></span><br><span class="line">cluster-enabled <span class="built_in">yes</span> <span class="comment"># 打开集群模式</span></span><br><span class="line">cluster-config-file nodes-6379.conf <span class="comment"># 设置节点配置文件名称，需要更改</span></span><br><span class="line">cluster-node-timeout 15000 <span class="comment"># 设置节点失联事件，超过该时间（ms），集群自动进行主从切换</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/02/redis/20211030200232.png" alt="20211030 200232"></p>
<ol start="2">
<li>启动</li>
</ol>
<p><img src="/2023/02/02/redis/20211030200804.png" alt="20211030 200804"></p>
<ol start="3">
<li>将 6 个节点合成一个集群</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 组合之前请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常。</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/02/redis/20211031140952.png" alt="20211031 140952"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入redis安装目录</span></span><br><span class="line">/opt/redis-6.2.6/src</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line">redis-cli --cluster create --cluster-replicas 1 172.16.88.168:6379 172.16.88.168:6380 172.16.88.168:6381 172.16.88.168:6389 172.16.88.168:6390 172.16.88.168:6391</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/02/redis/20211031141216.png" alt="20211031 141216"></p>
<ol start="4">
<li>采用集群策略连接</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -c -p PORT</span><br><span class="line">cluster nodes <span class="comment"># 命令查看集群信息</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/02/redis/20211031141531.png" alt="20211031 141531"></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="redis-cluster-如何分配这六个节点"><a href="#redis-cluster-如何分配这六个节点" class="headerlink" title="redis cluster 如何分配这六个节点?"></a><em>redis cluster</em> 如何分配这六个节点?</h3><blockquote>
<p>一个集群至少要有三个主节点。</p>
<p>选项 <code>--cluster-replicas 1</code>，表示希望为集群中的每个主节点创建一个从节点。</p>
<p>分配原则尽量保证每个主数据库运行在不同的 <em><strong>IP</strong></em> 地址，每个从库和主库不在一个 <em><strong>IP</strong></em> 地址上。</p>
<p><img src="/2023/02/02/redis/20211031143026.png" alt="20211031 143026"></p>
</blockquote>
<h3 id="什么是-slots？"><a href="#什么是-slots？" class="headerlink" title="什么是 slots？"></a>什么是 <em>slots</em>？</h3><p><img src="/2023/02/02/redis/20211031142125.png" alt="20211031 142125"></p>
<p><img src="/2023/02/02/redis/20211031141531.png" alt="20211031 141531"></p>
<blockquote>
<p>一个 <em><strong>Redis</strong></em> 集群包含 <em><strong>16384</strong></em> 个插槽（<em><strong>hash slot</strong></em>）， 数据库中的每个键都属于这 <em><strong>16384</strong></em> 个插槽的其中一个。</p>
<p>集群使用公式 <em><strong>CRC16(key) % 16384</strong></em> 来计算键 <em><strong>key</strong></em> 属于哪个槽， 其中 <em><strong>CRC16(key)</strong></em> 语句用于计算键 <em><strong>key</strong></em> 的 <em><strong>CRC16</strong></em> 校验和 。</p>
<p>集群中的每个节点负责处理一部分插槽。 例如， 如果一个集群可以有主节点， 其中：</p>
<ul>
<li>节点 <em><strong>A</strong></em> 负责处理 <em><strong>0</strong></em> 号至 <em><strong>5460</strong></em> 号插槽。</li>
<li>节点 <em><strong>B</strong></em> 负责处理 <em><strong>5461</strong></em> 号至 <em><strong>10922</strong></em> 号插槽。</li>
<li>节点 <em><strong>C</strong></em> 负责处理 <em><strong>10923</strong></em> 号至 <em><strong>16383</strong></em> 号插槽。</li>
</ul>
</blockquote>
<h3 id="如何在集群中录入值？"><a href="#如何在集群中录入值？" class="headerlink" title="如何在集群中录入值？"></a>如何在集群中录入值？</h3><blockquote>
<p>在 <em><strong>redis-cli</strong></em> 每次录入、查询键值，<em><strong>redis</strong></em> 都会计算出该 <em><strong>key</strong></em> 应该送往的插槽，如果不是该客户端对应服务器的插槽，<em><strong>redis</strong></em> 会报错，并告知应前往的 <em><strong>redis</strong></em> 实例地址和端口。</p>
<p><em><strong>redis-cli</strong></em> 客户端提供了 <em><strong>–c</strong></em> 参数实现自动重定向。</p>
<p>例如 <em><strong>redis-cli -c –p 6379</strong></em> 登入后，再录入、查询键值对可以自动重定向。</p>
</blockquote>
<h3 id="如何查询集群中的值？"><a href="#如何查询集群中的值？" class="headerlink" title="如何查询集群中的值？"></a>如何查询集群中的值？</h3><blockquote>
<p>每个主机只能查询自己范围内部的插槽。</p>
<p><code>cluster keyslot &lt;key&gt;</code>：查询某个 <em><strong>key</strong></em> 的 **<em>slot</em> **。</p>
<p><code>cluster countkeysinslot &lt;slot&gt;</code>：查询某个 <em><strong>slot</strong></em> 是否有值。</p>
<p><code>CLUSTER GETKEYSINSLOT &lt;slot&gt;&lt;count&gt;</code>：返回 <em><strong>count</strong></em> 个 <em><strong>slot</strong></em> 槽中的键。</p>
</blockquote>
<h3 id="故障恢复？"><a href="#故障恢复？" class="headerlink" title="故障恢复？"></a>故障恢复？</h3><blockquote>
<p>如果主节点下线？从节点能否自动升为主节点？注意：<em><strong>15</strong></em> 秒超时。</p>
<p><img src="/2023/02/02/redis/20211031144226.png" alt="20211031 144226"></p>
<ul>
<li>当 <em><strong>6379</strong></em> 挂掉后，<em><strong>6389</strong></em> 成为新的主机。</li>
</ul>
<p>主节点恢复后，主从关系会如何？主节点回来变成从机。</p>
<ul>
<li>当 <em><strong>6379</strong></em> 重启后，<em><strong>6379</strong></em> 成为 <em><strong>6389</strong></em> 的从机。</li>
</ul>
<p>如果所有某一段插槽的主从节点都宕掉，<em><strong>redis</strong></em> 服务是否还能继续?</p>
<ul>
<li>如果某一段插槽的主从都挂掉，而 <em><strong>cluster-require-full-coverage&#x3D;yes</strong></em>，那么 ，整个集群都挂掉。</li>
<li>如果某一段插槽的主从都挂掉，而 <em><strong>cluster-require-full-coverage&#x3D;no</strong></em>，那么，该插槽数据全都不能使用，也无法存储。</li>
</ul>
<p><code>redis.conf</code> 中的参数 <code>cluster-require-full-coverage</code></p>
</blockquote>
<h2 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h2><ul>
<li>实现扩容；</li>
<li>分摊压力；</li>
<li>无中心配置相对简单。</li>
</ul>
<h2 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>多键操作是不被支持的；</li>
<li>多键的 <em><strong>Redis</strong></em> 事务是不被支持的。<em><strong>lua</strong></em> 脚本不被支持；</li>
<li>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至<em><strong>redis cluster</strong></em>，需要整体迁移而不是逐步过渡，复杂度较大。</li>
</ul>
<h1 id="Jedis操作Redis"><a href="#Jedis操作Redis" class="headerlink" title="Jedis操作Redis"></a>Jedis操作Redis</h1><p>即 <em><strong>Java</strong></em> 操作 <em><strong>Redis</strong></em>。</p>
<ol>
<li>依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>连接 <em><strong>Redis</strong></em></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.57.101&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">pong</span> <span class="operator">=</span> jedis.ping();</span><br><span class="line">    System.out.println(<span class="string">&quot;连接成功：&quot;</span> + pong);</span><br><span class="line">    jedis.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><em><strong>Key</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jedis.set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>);</span><br><span class="line">Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">System.out.println(keys.size());</span><br><span class="line"><span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(jedis.exists(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">System.out.println(jedis.ttl(<span class="string">&quot;k1&quot;</span>));                </span><br><span class="line">System.out.println(jedis.get(<span class="string">&quot;k1&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><em><strong>String</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jedis.mset(<span class="string">&quot;str1&quot;</span>,<span class="string">&quot;v1&quot;</span>,<span class="string">&quot;str2&quot;</span>,<span class="string">&quot;v2&quot;</span>,<span class="string">&quot;str3&quot;</span>,<span class="string">&quot;v3&quot;</span>);</span><br><span class="line">System.out.println(jedis.mget(<span class="string">&quot;str1&quot;</span>,<span class="string">&quot;str2&quot;</span>,<span class="string">&quot;str3&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><em><strong>List</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = jedis.lrange(<span class="string">&quot;mylist&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (String element : list) &#123;</span><br><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>Set</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order01&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order02&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order03&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order04&quot;</span>);</span><br><span class="line">Set&lt;String&gt; smembers = jedis.smembers(<span class="string">&quot;orders&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String order : smembers) &#123;</span><br><span class="line">System.out.println(order);</span><br><span class="line">&#125;</span><br><span class="line">jedis.srem(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order02&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><em><strong>Hash</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jedis.hset(<span class="string">&quot;hash1&quot;</span>,<span class="string">&quot;userName&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">System.out.println(jedis.hget(<span class="string">&quot;hash1&quot;</span>,<span class="string">&quot;userName&quot;</span>));</span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;telphone&quot;</span>,<span class="string">&quot;13810169999&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;address&quot;</span>,<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;abc@163.com&quot;</span>);</span><br><span class="line">jedis.hmset(<span class="string">&quot;hash2&quot;</span>,map);</span><br><span class="line">List&lt;String&gt; result = jedis.hmget(<span class="string">&quot;hash2&quot;</span>, <span class="string">&quot;telphone&quot;</span>,<span class="string">&quot;email&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String element : result) &#123;</span><br><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>zset</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">100d</span>, <span class="string">&quot;z3&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">90d</span>, <span class="string">&quot;l4&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">80d</span>, <span class="string">&quot;w5&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">70d</span>, <span class="string">&quot;z6&quot;</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; zrange = jedis.zrange(<span class="string">&quot;zset01&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (String e : zrange) &#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Jedis-主从复制"><a href="#Jedis-主从复制" class="headerlink" title="Jedis 主从复制"></a><em>Jedis</em> 主从复制</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> JedisSentinelPool jedisSentinelPool=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  Jedis <span class="title function_">getJedisFromSentinel</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(jedisSentinelPool==<span class="literal">null</span>)&#123;</span><br><span class="line">    Set&lt;String&gt; sentinelSet=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    sentinelSet.add(<span class="string">&quot;172.16.88.168:26379&quot;</span>); <span class="comment">// 端口为sentinal</span></span><br><span class="line">    <span class="type">JedisPoolConfig</span> <span class="variable">jedisPoolConfig</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">    jedisPoolConfig.setMaxTotal(<span class="number">10</span>); <span class="comment">// 最大可用连接数</span></span><br><span class="line">    jedisPoolConfig.setMaxIdle(<span class="number">5</span>); <span class="comment">// 最大闲置连接数</span></span><br><span class="line">    jedisPoolConfig.setMinIdle(<span class="number">5</span>); <span class="comment">// 最小闲置连接数</span></span><br><span class="line">    jedisPoolConfig.setBlockWhenExhausted(<span class="literal">true</span>); <span class="comment">// 连接耗尽是否等待</span></span><br><span class="line">    jedisPoolConfig.setMaxWaitMillis(<span class="number">2000</span>); <span class="comment">// 等待时间</span></span><br><span class="line">    jedisPoolConfig.setTestOnBorrow(<span class="literal">true</span>); <span class="comment">// 取连接的时候进行测试</span></span><br><span class="line"></span><br><span class="line">    jedisSentinelPool=<span class="keyword">new</span> <span class="title class_">JedisSentinelPool</span>(<span class="string">&quot;mymaster&quot;</span>,sentinelSet,jedisPoolConfig); <span class="comment">// 服务主机名</span></span><br><span class="line">    <span class="keyword">return</span> jedisSentinelPool.getResource();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> jedisSentinelPool.getResource();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="集群的-Jedis-开发"><a href="#集群的-Jedis-开发" class="headerlink" title="集群的 Jedis 开发"></a>集群的 <em>Jedis</em> 开发</h2><p>即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。</p>
<p>无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisClusterTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">     Set&lt;HostAndPort&gt;set =<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;HostAndPort&gt;();</span><br><span class="line">     set.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;172.16.88.168&quot;</span>,<span class="number">6379</span>)); <span class="comment">// 任何一个端口</span></span><br><span class="line">     <span class="type">JedisCluster</span> <span class="variable">jedisCluster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisCluster</span>(set);</span><br><span class="line">     jedisCluster.set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">     System.out.println(jedisCluster.get(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h1><ol>
<li>依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置文件配置 <em><strong>Redis</strong></em></li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Redis服务器地址</span></span><br><span class="line"><span class="attr">spring.redis.host</span>= <span class="string">ip</span></span><br><span class="line"><span class="comment">#Redis服务器连接端口</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment">#Redis数据库索引（默认为0）</span></span><br><span class="line"><span class="attr">spring.redis.database</span>= <span class="string">0</span></span><br><span class="line"><span class="comment">#连接超时时间（毫秒）</span></span><br><span class="line"><span class="attr">spring.redis.timeout</span>=<span class="string">1800000</span></span><br><span class="line"><span class="comment">#连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="comment">#最大阻塞等待时间(负数表示没限制)</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment">#连接池中的最大空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="comment">#连接池中的最小空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><em><strong>Redis</strong></em> 配置类（需要继承 <em><strong>CachingConfigurerSupport</strong></em>）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">				<span class="comment">// key序列化方式</span></span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line">				<span class="comment">// value序列化</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">				<span class="comment">// value hashmap序列化</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">				<span class="comment">// 解决查询缓存转换异常的问题</span></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">				<span class="comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span></span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> </span><br><span class="line">          RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">      .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        <span class="type">RedisCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="应用问题解决"><a href="#应用问题解决" class="headerlink" title="应用问题解决"></a>应用问题解决</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><img src="/2023/02/02/redis/20211031150258.png" alt="20211031 150258"></p>
<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p><em><strong>key</strong></em> 对应的数据在数据源并不存在，每次针对此 <em><strong>key</strong></em> 的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。</p>
<p>比如用一个不存在的用户 <em><strong>id</strong></em> 获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p>
<p>造成：</p>
<ol>
<li>应用服务器压力变大。</li>
<li><em><strong>redis</strong></em> 命中率下降 $\longrightarrow$ 查询数据库 。</li>
</ol>
<h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><ul>
<li><p><strong>对空值缓存</strong></p>
<p>如果一个查询返回的数据为空（不管是数据是否不存在），仍然把这个空结果（<em><strong>null</strong></em>）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟。</p>
</li>
<li><p><strong>设置可访问的名单（白名单）：</strong></p>
<p>使用 <em><strong>bitmaps</strong></em> 类型定义一个可以访问的名单，名单 <em><strong>id</strong></em> 作为 <em><strong>bitmaps</strong></em> 的偏移量，每次访问和 <em><strong>bitmap</strong></em> 里面的 <em><strong>id</strong></em> 进行比较，如果访问 <em><strong>id</strong></em> 不在 <em><strong>bitmaps</strong></em> 里面，进行拦截，则不允许访问。</p>
</li>
<li><p><strong>采用布隆过滤器</strong></p>
<p>布隆过滤器（<em><strong>Bloom Filter</strong></em>）是1970年由布隆提出的。它实际上是一个很长的二进制向量（位图）和一系列随机映射函数（哈希函数）。</p>
<p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p>
<p>将所有可能存在的数据哈希到一个足够大的 <em><strong>bitmaps</strong></em> 中，一个一定不存在的数据会被这个 <em><strong>bitmaps</strong></em> 拦截掉，从而避免了对底层存储系统的查询压力。</p>
</li>
<li><p><strong>进行实时监控</strong></p>
<p>当发现 <em><strong>Redis</strong></em> 的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。</p>
</li>
</ul>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><img src="/2023/02/02/redis/20211031151809.png" alt="20211031 151809"></p>
<p><em><strong>key</strong></em> 对应的数据存在，但在 <em><strong>redis</strong></em> 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端<em><strong>DB</strong></em> 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 <em><strong>DB</strong></em> 压垮。</p>
<ol>
<li>数据库访问压力瞬间增大。</li>
<li><em><strong>redis</strong></em> 中没有出现大量 <em><strong>key</strong></em> 过期，<em><strong>redis</strong></em> 正常运行。</li>
<li>（即某个经常访问的 <em><strong>key</strong></em> 过期，突然有大量访问这个数据）</li>
</ol>
<h3 id="如何解决-1"><a href="#如何解决-1" class="headerlink" title="如何解决"></a>如何解决</h3><ul>
<li><p>预先设置热门数据</p>
<p>在 <em><strong>redis</strong></em> 高峰访问之前，把一些热门数据提前存入到 <em><strong>redis</strong></em> 里面，加大这些热门数据 <em><strong>key</strong></em> 的时长。</p>
</li>
<li><p>实时调整</p>
<p>现场监控哪些数据热门，实时调整 <em><strong>key</strong></em> 的过期时长。</p>
</li>
<li><p>使用锁</p>
</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><em><strong>key</strong></em> 对应的数据存在，但在 <em><strong>redis</strong></em> 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端<em><strong>DB</strong></em> 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 <em><strong>DB</strong></em> 压垮。</p>
<p>缓存雪崩与缓存击穿的区别在于这里针对很多 <em><strong>key</strong></em> 缓存，前者则是某一个 <em><strong>key</strong></em>。</p>
<ol>
<li>数据库压力变大。</li>
<li>即极少的时间段，查询大量 <em><strong>key</strong></em> 的集中过期情况。</li>
</ol>
<h3 id="如何解决-2"><a href="#如何解决-2" class="headerlink" title="如何解决"></a>如何解决</h3><ul>
<li><p><strong>构建多级缓存架构</strong></p>
<p><em><strong>nginx</strong></em> 缓存 + <em><strong>redis</strong></em> 缓存 + 其他缓存（<em><strong>ehcache</strong></em>等）</p>
</li>
<li><p><strong>使用锁或队列：</strong></p>
<p>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况。</p>
</li>
<li><p><strong>设置过期标志更新缓存：</strong></p>
<p>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际 <em><strong>key</strong></em> 的缓存。</p>
</li>
<li><p><strong>将缓存失效时间分散开：</strong></p>
<p>比如我们可以在原有的失效时间基础上增加一个随机值，比如 1～5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
</li>
</ul>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>$###################\space to \space do\space ###################$</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Rv41177Af">https://www.bilibili.com/video/BV1Rv41177Af</a>)</li>
</ul>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/2022/12/17/JVM/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul>
<li>$\textcolor{OliveGreen}{一次编写，到处运行}$</li>
<li>$\textcolor{OliveGreen}{自动内存管理，垃圾回收机制}$</li>
<li>$\textcolor{OliveGreen}{数组下标越界检查}$</li>
</ul>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>JVM JRE JDK的区别</p>
<p><img src="/2022/12/17/JVM/20200608150422.png" alt="20200608150422"></p>
<h1 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="/2022/12/17/JVM/20200608150440.png" alt="20200608150440"></p>
<h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h3><h4 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1.1 作用"></a>1.1 作用</h4><p>$\textcolor{OliveGreen}{用于保存jvm中下一条所要执行的指令的地址}$</p>
<h4 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h4><ul>
<li>$\textcolor{OliveGreen}{线程私有}$<ul>
<li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li>
<li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li>
</ul>
</li>
<li>$\textcolor{OliveGreen}{不会存在内存溢出}$</li>
</ul>
<h3 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2.虚拟机栈"></a>2.虚拟机栈</h3><ul>
<li>-Xss</li>
</ul>
<h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><ul>
<li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li>
<li>每个栈由多个<strong>栈帧</strong>组成，对应着每次方法调用时所占用的内存</li>
<li>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong></li>
</ul>
<h5 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		method1();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">		method2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/12/17/JVM/20200608150534.png" alt="20200608150534"></p>
<p>在控制台中可以看到，主类中的方法在进入虚拟机栈的时候，符合栈的特点</p>
<h5 id="问题辨析"><a href="#问题辨析" class="headerlink" title="问题辨析"></a>问题辨析</h5><ul>
<li>垃圾回收是否涉及栈内存？<ul>
<li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li>
</ul>
</li>
<li>栈内存的分配越大越好吗？<ul>
<li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li>
</ul>
</li>
<li>方法内的局部变量是否是线程安全的？<ul>
<li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的</li>
<li>如果如果<strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</li>
</ul>
</li>
</ul>
<h4 id="2-2-内存溢出"><a href="#2-2-内存溢出" class="headerlink" title="2.2 内存溢出"></a>2.2 内存溢出</h4><p><code>Java.lang.stackOverflowError</code> 栈内存溢出</p>
<h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><ul>
<li>$\textcolor{OliveGreen}{虚拟机栈中，栈帧过多（无限递归）}$</li>
<li>$\textcolor{OliveGreen}{每个栈帧所占用过大}$</li>
</ul>
<h4 id="2-3-线程运行诊断"><a href="#2-3-线程运行诊断" class="headerlink" title="2.3 线程运行诊断"></a>2.3 线程运行诊断</h4><p>CPU占用过高</p>
<ul>
<li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程<ul>
<li><code>top</code>命令，查看是哪个<strong>进程</strong>占用CPU过高</li>
<li><code>ps H -eo pid, tid, %cpu | grep + 进程id</code>  通过 <code>ps</code>命令进一步查看是哪个<strong>线程</strong>占用CPU过高</li>
<li><code>jstack + 进程id</code> 通过查看进程中的线程的<code>tid</code>，通过<code>ps</code>命令查看的<code>tid</code>来<strong>对比定位</strong>，注意<code>jstack</code>查找出的线程<code>tid</code>是<strong>16进制的</strong>，<strong>需要转换</strong></li>
</ul>
</li>
</ul>
<h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h3><p>一些带有<code>native</code><strong>关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法</p>
<h3 id="4-堆"><a href="#4-堆" class="headerlink" title="4.堆"></a>4.堆</h3><ul>
<li>-Xmx</li>
</ul>
<h4 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h4><p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>$\textcolor{OliveGreen}{所有线程共享，堆内存中的对象都需要考虑线程安全问题}$</li>
<li>$ \textcolor{OliveGreen}{有垃圾回收机制}$</li>
</ul>
<h4 id="4-2-堆内存溢出"><a href="#4-2-堆内存溢出" class="headerlink" title="4.2 堆内存溢出"></a>4.2 堆内存溢出</h4><p><code>java.lang.OutofMemoryError: Java heap space </code> 堆内存溢出</p>
<h4 id="4-3-堆内存诊断工具"><a href="#4-3-堆内存诊断工具" class="headerlink" title="4.3 堆内存诊断工具"></a>4.3 堆内存诊断工具</h4><ul>
<li><p><code>jps</code></p>
<ul>
<li>查看当前系统中有哪些java进程</li>
</ul>
</li>
<li><p><code>jmap</code></p>
<ul>
<li>查看堆内存占用情况（某一时刻）</li>
</ul>
</li>
<li><p><code>jconsole</code></p>
<ul>
<li>图形化界面，多功能的监测工具，可以连续监测</li>
</ul>
</li>
<li><p><code>jvirsalvm</code></p>
</li>
</ul>
<h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5.方法区"></a>5.方法区</h3><h4 id="5-1-结构"><a href="#5-1-结构" class="headerlink" title="5.1 结构"></a>5.1 结构</h4><p><img src="/2022/12/17/JVM/20200608150547.png" alt="20200608150547"></p>
<h4 id="5-2-内存溢出"><a href="#5-2-内存溢出" class="headerlink" title="5.2 内存溢出"></a>5.2 内存溢出</h4><ul>
<li>1.8以前会导致<strong>永久代</strong>内存溢出 <ul>
<li><code>-XX:MaxPermSize=8m</code></li>
<li><code>java.lang.OutOfMemoryError: PermGen space</code></li>
</ul>
</li>
<li>1.8以后会导致<strong>元空间</strong>内存溢出<ul>
<li>元空间使用系统内存</li>
<li><code> -XX:MaxMetaspaceSize=8m</code></li>
<li><code>java.lang.OutOfMemoryError: Metaspace</code></li>
</ul>
</li>
</ul>
<h4 id="5-3-运行时常量池"><a href="#5-3-运行时常量池" class="headerlink" title="5.3 运行时常量池"></a>5.3 运行时常量池</h4><ul>
<li><p>二进制字节码的组成</p>
<ul>
<li>类的基本信息</li>
<li>常量池</li>
<li>类的方法定义（包含了虚拟机指令）</li>
</ul>
</li>
<li><p>通过反编译来查看类的信息</p>
<ul>
<li><p>获得对应类的.class文件</p>
</li>
<li><p>在控制台输入 javap -v 类的路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javap -v xxx.class</span><br></pre></td></tr></table></figure>
</li>
<li><p>在控制台看到反编译以后类的信息了</p>
<ul>
<li><p>类的基本信息</p>
<p><img src="/2022/12/17/JVM/20200608150618.png" alt="20200608150618"></p>
</li>
<li><p>常量池</p>
<p><img src="/2022/12/17/JVM/20200608150630.png" alt="20200608150630"></p>
<p><img src="/2022/12/17/JVM/20200608150641.png" alt="20200608150641"></p>
</li>
<li><p>虚拟机中执行编译的方法（框内的是真正编译执行的内容，**#号的内容需要在常量池中查找**）</p>
<p><img src="/2022/12/17/JVM/20200608150653.png" alt="20200608150653"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="常量池与运行时常量池的区别"><a href="#常量池与运行时常量池的区别" class="headerlink" title="常量池与运行时常量池的区别"></a>常量池与运行时常量池的区别</h5><ul>
<li>常量池<ul>
<li>就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</li>
</ul>
</li>
<li>运行时常量池<ul>
<li>常量池是*.class文件中的，当该<strong>类被加载以后</strong>，它的常量池信息就会<strong>放入运行时常量池</strong>，并把里面的<strong>符号地址变为真实地址</strong></li>
</ul>
</li>
</ul>
<h4 id><a href="#" class="headerlink" title></a></h4><h4 id="5-4-常量池与串池的关系"><a href="#5-4-常量池与串池的关系" class="headerlink" title="5.4 常量池与串池的关系"></a>5.4 常量池与串池的关系</h4><h4 id="5-5-串池-String-space-Table"><a href="#5-5-串池-String-space-Table" class="headerlink" title="5.5 串池 $String\space Table$"></a>5.5 <strong>串池</strong> $String\space Table$</h4><ul>
<li>特征<ul>
<li>常量池中的字符串仅是符号，只有<strong>在被用到时才会转化为对象</strong></li>
<li>利用串池的机制，来避免重复创建字符串对象</li>
<li>字符串<strong>变量</strong>拼接的原理是 <strong>StringBuilder</strong></li>
<li>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></li>
<li>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</li>
<li><strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</li>
</ul>
</li>
</ul>
<p>用来放字符串对象且里面的<strong>元素不重复</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableStudy</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>; </span><br><span class="line">		<span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，<strong>还没有成为java字符串</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: ldc           #2                  // String a</span><br><span class="line">2: astore_1</span><br><span class="line">3: ldc           #3                  // String b</span><br><span class="line">5: astore_2</span><br><span class="line">6: ldc           #4                  // String ab</span><br><span class="line">8: astore_3</span><br><span class="line">9: returnCopy</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong>（hashtable结构 不可扩容）</p>
</li>
<li><p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p>
</li>
<li><p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p>
</li>
</ul>
<p>最终 <strong>StringTable [“a”, “b”, “ab”]</strong></p>
<p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p>
<p>使用拼接<strong>字符串变量对象</strong>创建字符串的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableStudy</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">		<span class="comment">// 拼接字符串对象来创建新的字符串</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">ab2</span> <span class="operator">=</span> a+b; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译后的结果</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">  stack=2, locals=6, args_size=1</span><br><span class="line">     0: ldc           #2         // String a</span><br><span class="line">     2: astore_1</span><br><span class="line">     3: ldc           #3         // String b</span><br><span class="line">     5: astore_2</span><br><span class="line">     6: ldc           #4         // String ab</span><br><span class="line">     8: astore_3</span><br><span class="line">     9: new           #5         // class java/lang/StringBuilder</span><br><span class="line">    12: dup</span><br><span class="line">    13: invokespecial #6         // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">    16: aload_1</span><br><span class="line">    17: invokevirtual #7         // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">    20: aload_2</span><br><span class="line">    21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">    24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">    27: astore        4</span><br><span class="line">    //ab3初始化时直接从串池中获取字符串</span><br><span class="line">    29: ldc           #4                  // String ab</span><br><span class="line">    31: astore        5</span><br><span class="line">    33: return</span><br></pre></td></tr></table></figure>

<p>通过拼接的方式来创建字符串的<strong>过程</strong>是：<code>new StringBuilder().append(“a”).append(“b”).toString()</code></p>
<p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ab2</span> <span class="operator">=</span> a+b;</span><br><span class="line"><span class="comment">//结果为false,因为ab是存在于串池之中，ab2是由StringBuffer的toString方法所返回的一个对象，存在于堆内存之中</span></span><br><span class="line">System.out.println(ab == ab2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>



<p>使用<strong>拼接字符串常量对象</strong>的方法创建字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableStudy</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">ab2</span> <span class="operator">=</span> a+b;</span><br><span class="line">		<span class="comment">//使用拼接字符串的方法创建字符串</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">ab3</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    System.out.println(ab == ab3); <span class="comment">// true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译后的结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">  stack=2, locals=6, args_size=1</span><br><span class="line">     0: ldc           #2                  // String a</span><br><span class="line">     2: astore_1</span><br><span class="line">     3: ldc           #3                  // String b</span><br><span class="line">     5: astore_2</span><br><span class="line">     6: ldc           #4                  // String ab</span><br><span class="line">     8: astore_3</span><br><span class="line">     9: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">    12: dup</span><br><span class="line">    13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">    16: aload_1</span><br><span class="line">    17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">    20: aload_2</span><br><span class="line">    21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">    24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">    27: astore        4</span><br><span class="line">    //ab3初始化时直接从串池中获取字符串</span><br><span class="line">    29: ldc           #4                  // String ab</span><br><span class="line">    31: astore        5</span><br><span class="line">    33: returnCopy</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab &#x3D; “ab” 一致。</p>
</li>
<li><p>使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></p>
</li>
</ul>
<h5 id="intern方法-1-8"><a href="#intern方法-1-8" class="headerlink" title="intern方法 1.8"></a>intern方法 1.8</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p>
<ul>
<li>如果串池中没有该字符串对象，则放入成功</li>
<li>如果有该字符串对象，则放入失败</li>
</ul>
<p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p>
<p><strong>注意</strong>：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p>
<p><strong>例1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 串池：&quot;a&quot; &quot;b&quot; </span></span><br><span class="line">    <span class="comment">// 堆：str new StringBuild.append(&quot;a&quot;).appned(&quot;b&quot;).toStirng()</span></span><br><span class="line">    <span class="comment">// 堆：new String(&quot;a&quot;) </span></span><br><span class="line">    <span class="comment">// 堆：new String(&quot;b&quot;) </span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 调用str的intern方法，此时串池中没有&quot;ab&quot;，则会将该字符串对象放入到串池中，此时堆内存与串池中的&quot;ab&quot;是同一个对象</span></span><br><span class="line">   	<span class="comment">// 将&quot;ab&quot;对象返回给str2</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str.intern();</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 因为堆内存与串池中的&quot;ab&quot;是同一个对象，所以以下两条语句打印的都为true</span></span><br><span class="line">		System.out.println(str == st2); <span class="comment">// true</span></span><br><span class="line">		System.out.println(str == str3); <span class="comment">// true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例2</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 此处创建字符串对象&quot;ab&quot;，因为串池中还没有&quot;ab&quot;，所以将其放入串池中</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 串池：&quot;a&quot; &quot;b&quot; 被放入串池中</span></span><br><span class="line">    <span class="comment">// 堆：str</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 此时因为在创建str3时，&quot;ab&quot;已存在与串池中，所以放入失败，但是会返回串池中的&quot;ab&quot;</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str.intern();</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 堆中与串池中&quot;ab&quot;不一样</span></span><br><span class="line">		System.out.println(str == str2);  <span class="comment">// false</span></span><br><span class="line">		System.out.println(str == str3); <span class="comment">// false</span></span><br><span class="line">		System.out.println(str2 == str3);  <span class="comment">// true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="intern方法-1-6"><a href="#intern方法-1-6" class="headerlink" title="intern方法 1.6"></a>intern方法 1.6</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p>
<ul>
<li>如果串池中没有该字符串对象，会将该字符串对象<strong>复制</strong>一份，再放入到串池中</li>
<li>如果有该字符串对象，则放入失败</li>
</ul>
<p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p>
<p><strong>注意</strong>：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></p>
<p><strong>例1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 串池：&quot;a&quot; &quot;b&quot; </span></span><br><span class="line">    <span class="comment">// 堆：str new StringBuild.append(&quot;a&quot;).appned(&quot;b&quot;).toStirng()</span></span><br><span class="line">    <span class="comment">// 堆：new String(&quot;a&quot;) </span></span><br><span class="line">    <span class="comment">// 堆：new String(&quot;b&quot;) </span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 调用str的intern方法，此时串池中没有&quot;ab&quot;，则会将该字符串对象复制一份放入到串池中，此时堆内存与串池中的&quot;ab&quot;不是是同一个对象</span></span><br><span class="line">    <span class="comment">// 串池：str2</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str.intern();</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回</span></span><br><span class="line">    <span class="comment">// 串池：str3</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 堆内存并不是与串池&quot;ab为同一个对象</span></span><br><span class="line">		System.out.println(str == st2); <span class="comment">// false</span></span><br><span class="line">		System.out.println(str == str3); <span class="comment">// false</span></span><br><span class="line">    System.out.println(str2 == str3); <span class="comment">// true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例2</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 此处创建字符串对象&quot;ab&quot;，因为串池中还没有&quot;ab&quot;，所以将其放入串池中</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 串池：&quot;a&quot; &quot;b&quot; 被放入串池中</span></span><br><span class="line">    <span class="comment">// 堆：str</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 此时因为在创建str3时，&quot;ab&quot;已存在与串池中，所以放入失败，返回串池中的&quot;ab&quot;</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str.intern();</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 堆中与串池中&quot;ab&quot;不一样</span></span><br><span class="line">		System.out.println(str == str2);  <span class="comment">// false</span></span><br><span class="line">		System.out.println(str == str3); <span class="comment">// false</span></span><br><span class="line">		System.out.println(str2 == str3);  <span class="comment">// true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jvm1.8</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 串池：s1 s2 s3 s5 s6</span></span><br><span class="line">    <span class="comment">// 堆：s4</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s4.intern();</span><br><span class="line">    </span><br><span class="line">    System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line">    System.out.println(s3 == s5); <span class="comment">// true</span></span><br><span class="line">    System.out.println(s3 == s6); <span class="comment">// true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 串池：&quot;c&quot; &quot;d&quot; x1=&quot;cd&quot;</span></span><br><span class="line">    <span class="comment">// 堆：x2=&quot;cd&quot;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">x2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="string">&quot;cd&quot;</span>;</span><br><span class="line">    <span class="comment">// 串池中已经存在&quot;cd&quot;，放入失败</span></span><br><span class="line">    x2.intern();</span><br><span class="line">    </span><br><span class="line">    System.out.println(x1 == x2); <span class="comment">// false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-6-StringTable-位置"><a href="#5-6-StringTable-位置" class="headerlink" title="5.6 StringTable 位置"></a>5.6 StringTable 位置</h4><p><img src="/2022/12/17/JVM/20200608150547.png" alt="img"></p>
<h4 id="5-7-StringTable-垃圾回收"><a href="#5-7-StringTable-垃圾回收" class="headerlink" title="5.7 StringTable 垃圾回收"></a>5.7 StringTable 垃圾回收</h4><p>StringTable在内存紧张时，会发生垃圾回收</p>
<h4 id="5-8-StringTable-调优"><a href="#5-8-StringTable-调优" class="headerlink" title="5.8 StringTable 调优"></a>5.8 StringTable 调优</h4><ul>
<li><p>因为StringTable是由HashTable实现的，所以可以<strong>适当增加HashTable桶的个数</strong>，来减少字符串放入串池所需要的时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:StringTableSize=xxxx(🪣个数)</span><br></pre></td></tr></table></figure>
</li>
<li><p>考虑是否需要将字符串对象入池</p>
<p>可以通过<strong>intern方法减少重复入池</strong></p>
</li>
</ul>
<h3 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6.直接内存"></a>6.直接内存</h3><ul>
<li>属于操作系统，常见于NIO操作时，<strong>用于数据缓冲区</strong></li>
<li>分配回收成本较高，但读写性能高</li>
<li>不受JVM内存回收管理</li>
</ul>
<h4 id="文件读写流程"><a href="#文件读写流程" class="headerlink" title="文件读写流程"></a>文件读写流程</h4><ul>
<li>IO</li>
</ul>
<p><img src="/2022/12/17/JVM/20200608150715.png" alt="20200608150715"></p>
<ul>
<li>DirectBuffer</li>
</ul>
<p><img src="/2022/12/17/JVM/20200608150736.png" alt="20200608150736"></p>
<p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高了效率</p>
<h4 id="释放原理-❓"><a href="#释放原理-❓" class="headerlink" title="释放原理 ❓"></a>释放原理 ❓</h4><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过 <code>unsafe.freeMemory</code> 来手动释放</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过ByteBuffer申请1M的直接内存</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_1M);Copy</span><br></pre></td></tr></table></figure>

<p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p>
<p>allocateDirect的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocateDirect</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectByteBuffer</span>(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DirectByteBuffer类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DirectByteBuffer(<span class="type">int</span> cap) &#123;   <span class="comment">// package-private</span></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pa</span> <span class="operator">=</span> VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ps</span> <span class="operator">=</span> Bits.pageSize();</span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">1L</span>, (<span class="type">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size); <span class="comment">//申请内存</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Deallocator</span>(base, size, cap)); <span class="comment">//通过虚引用，来实现直接内存的释放，this为虚引用的实际对象</span></span><br><span class="line">    att = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (remove(<span class="built_in">this</span>)) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="built_in">this</span>.thunk.run(); <span class="comment">//调用run方法</span></span><br><span class="line">           &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable var2) &#123;</span><br><span class="line">               AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                   <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (System.err != <span class="literal">null</span>) &#123;</span><br><span class="line">                           (<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       System.exit(<span class="number">1</span>);</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<p>对应对象的run方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Paranoia</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.freeMemory(address); <span class="comment">//释放直接内存中占用的内存</span></span><br><span class="line">    address = <span class="number">0</span>;</span><br><span class="line">    Bits.unreserveMemory(size, capacity);</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<h5 id="直接内存的回收机制总结"><a href="#直接内存的回收机制总结" class="headerlink" title="直接内存的回收机制总结"></a>直接内存的回收机制总结</h5><ul>
<li>使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法</li>
<li>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存</li>
</ul>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1.如何判断对象可以回收"></a>1.如何判断对象可以回收</h3><h4 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h4><p>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</p>
<p><img src="/2022/12/17/JVM/20200608150750.png" alt="20200608150750"></p>
<h4 id="1-2-可达性分析算法-❓"><a href="#1-2-可达性分析算法-❓" class="headerlink" title="1.2 可达性分析算法 ❓"></a>1.2 可达性分析算法 ❓</h4><ul>
<li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li>
<li>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li>
<li>可以作为GC Root的对象<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>
</ul>
</li>
</ul>
<h4 id="1-3-5种引用"><a href="#1-3-5种引用" class="headerlink" title="1.3 5种引用"></a>1.3 5种引用</h4><p><img src="/2022/12/17/JVM/20200608150800.png" alt="20200608150800"></p>
<h5 id="1-3-1-强引用"><a href="#1-3-1-强引用" class="headerlink" title="1.3.1 强引用"></a>1.3.1 强引用</h5><p>​	只有GC Root<strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p>
<p>​	如上图B、C对象都不引用A1对象时，A1对象才会被回收</p>
<h5 id="1-3-2-软引用"><a href="#1-3-2-软引用" class="headerlink" title="1.3.2 软引用"></a>1.3.2 软引用</h5><p>​	当GC Root指向软引用对象时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong></p>
<p>​	如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</p>
<p>​	软引用的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4M</span> <span class="operator">=</span> <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">		<span class="comment">// 使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span></span><br><span class="line">		List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		SoftReference&lt;<span class="type">byte</span>[]&gt; ref= <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4M]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>​	如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p>
<p>​	如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4M</span> <span class="operator">=</span> <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">		<span class="comment">// 使用引用队列，用于移除引用为空的软引用对象</span></span><br><span class="line">		ReferenceQueue&lt;<span class="type">byte</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">// 使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span></span><br><span class="line">		List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		SoftReference&lt;<span class="type">byte</span>[]&gt; ref= <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4M]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 遍历引用队列，如果有元素，则移除</span></span><br><span class="line">		Reference&lt;? <span class="keyword">extends</span> <span class="title class_">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line">		<span class="keyword">while</span>(poll != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 引用队列不为空，则从集合中移除该元素</span></span><br><span class="line">			list.remove(poll);</span><br><span class="line">			<span class="comment">//移动到引用队列中的下一个元素</span></span><br><span class="line">			<span class="type">po</span> <span class="variable">ll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p>
<h5 id="1-3-3-弱引用"><a href="#1-3-3-弱引用" class="headerlink" title="1.3.3 弱引用"></a>1.3.3 弱引用</h5><p>​	只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p>
<p>​	如上图如果B对象不再引用A3对象，则A3对象会被回收</p>
<p>​	<strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p>
<h5 id="1-3-4-虚引用"><a href="#1-3-4-虚引用" class="headerlink" title="1.3.4 虚引用"></a>1.3.4 虚引用</h5><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p>
<ul>
<li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li>
<li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li>
</ul>
<h5 id="1-3-5-终结器引用"><a href="#1-3-5-终结器引用" class="headerlink" title="1.3.5 终结器引用"></a>1.3.5 终结器引用</h5><p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p>
<ul>
<li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li>
</ul>
<h5 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h5><ul>
<li>软引用和弱引用<strong>可以配合</strong>引用队列<ul>
<li>在<strong>弱引用</strong>和<strong>虚引用</strong>所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软&#x2F;弱引用对象</li>
</ul>
</li>
<li>虚引用和终结器引用<strong>必须配合</strong>引用队列<ul>
<li>虚引用和终结器引用在使用时会关联一个引用队列</li>
</ul>
</li>
</ul>
<h3 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2.垃圾回收算法"></a>2.垃圾回收算法</h3><h4 id="2-1-标记-清除"><a href="#2-1-标记-清除" class="headerlink" title="2.1 标记-清除"></a>2.1 标记-清除</h4><p><img src="/2022/12/17/JVM/20200608150813.png" alt="20200608150813"></p>
<p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间</p>
<ul>
<li>这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存</li>
</ul>
<p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p>
<h4 id="2-2-标记-整理"><a href="#2-2-标记-整理" class="headerlink" title="2.2 标记-整理"></a>2.2 标记-整理</h4><p><img src="/2022/12/17/JVM/20200608150827.png" alt="20200608150827"></p>
<p>标记-整理 会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低</p>
<h4 id="2-3-复制"><a href="#2-3-复制" class="headerlink" title="2.3 复制"></a>2.3 复制</h4><p><img src="/2022/12/17/JVM/20200608150842.png" alt="20200608150842"></p>
<p><img src="/2022/12/17/JVM/20200608150856.png" alt="20200608150856"></p>
<p><img src="/2022/12/17/JVM/20200608150907.png" alt="20200608150907"></p>
<p><img src="/2022/12/17/JVM/20200608150919.png" alt="20200608150919"></p>
<p>将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。</p>
<h3 id="3-分代回收"><a href="#3-分代回收" class="headerlink" title="3.分代回收"></a>3.分代回收</h3><p><img src="/2022/12/17/JVM/20200608150931.png" alt="20200608150931"></p>
<h4 id="3-1-回收流程"><a href="#3-1-回收流程" class="headerlink" title="3.1 回收流程"></a>3.1 回收流程</h4><p>新创建的对象都被放在了<strong>新生代的伊甸园</strong>中</p>
<p><img src="/2022/12/17/JVM/20200608150939.png" alt="20200608150939"></p>
<p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong></p>
<p>Minor GC 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中， 并让其<strong>寿命加1</strong>，再<strong>交换两个幸存区</strong></p>
<p><img src="/2022/12/17/JVM/20200608150946.png" alt="20200608150946"></p>
<p><img src="/2022/12/17/JVM/20200608150955.png" alt="20200608150955"></p>
<p><img src="/2022/12/17/JVM/20200608151002.png" alt="20200608151002"></p>
<p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>stop the world</strong>， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p>
<p><img src="/2022/12/17/JVM/20200608151010.png" alt="20200608151010"></p>
<p>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会被<strong>放入老年代</strong>中</p>
<p><img src="/2022/12/17/JVM/20200608151018.png" alt="20200608151018"></p>
<p>如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p>
<h4 id="3-2-GC-分析"><a href="#3-2-GC-分析" class="headerlink" title="3.2 GC 分析"></a>3.2 GC 分析</h4><h5 id="3-2-1-GC相关参数"><a href="#3-2-1-GC相关参数" class="headerlink" title="3.2.1 GC相关参数"></a>3.2.1 GC相关参数</h5><table>
<thead>
<tr>
<th align="center">含义</th>
<th align="left">参数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">堆初始大小</td>
<td align="left">-Xms</td>
</tr>
<tr>
<td align="center">堆最大大小</td>
<td align="left">-Xmx 或 -XX:MaxHeapSize&#x3D;size</td>
</tr>
<tr>
<td align="center">新生代大小</td>
<td align="left">-Xmn 或 -XX:NewSize&#x3D;size + -XX:MaxNewSize&#x3D;size</td>
</tr>
<tr>
<td align="center">幸存区比例（动态）</td>
<td align="left">-XX:initialSurvivorRation&#x3D;ratio 或 -XX:+UseAdaptiveSizePolicy</td>
</tr>
<tr>
<td align="center">幸存区比例</td>
<td align="left">-XX:SurvivorRatio&#x3D;ratio</td>
</tr>
<tr>
<td align="center">晋升阈值</td>
<td align="left">-XX:MaxTenuringThreshold&#x3D;threshold</td>
</tr>
<tr>
<td align="center">晋升详情</td>
<td align="left">-XX:+PrintTenuringDistribution</td>
</tr>
<tr>
<td align="center">GC详情</td>
<td align="left">-XX:+PrintGCDetails -verbose:gc</td>
</tr>
<tr>
<td align="center">FullGC前MinorGC</td>
<td align="left">-XX:+ScavengeBeforeFullGC</td>
</tr>
</tbody></table>
<h5 id="3-2-2-大对象处理策略"><a href="#3-2-2-大对象处理策略" class="headerlink" title="3.2.2 大对象处理策略"></a>3.2.2 大对象处理策略</h5><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p>
<h5 id="3-2-3-线程内存溢出"><a href="#3-2-3-线程内存溢出" class="headerlink" title="3.2.3 线程内存溢出"></a>3.2.3 线程内存溢出</h5><p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行</p>
<p>这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p>
<h3 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4.垃圾回收器"></a>4.垃圾回收器</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>并行收集</strong>：指多条垃圾收集线程并行工作，但此时<strong>用户线程仍处于等待状态</strong>。</p>
<p><strong>并发收集</strong>：指用户线程与垃圾收集线程<strong>同时工作</strong>（不一定是并行的可能会交替执行）。<strong>用户程序在继续运行</strong>，而垃圾收集程序运行在另一个CPU上</p>
<p><strong>吞吐量</strong>：即CPU用于<strong>运行用户代码的时间</strong>与CPU<strong>总消耗时间</strong>的比值（吞吐量 &#x3D; 运行用户代码时间 &#x2F; ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p>
<h4 id="4-1-串行"><a href="#4-1-串行" class="headerlink" title="4.1 串行"></a>4.1 串行</h4><ul>
<li>单线程</li>
<li>内存较小，个人电脑（CPU核数较少）</li>
</ul>
<p><img src="/2022/12/17/JVM/20200608151027.png" alt="20200608151027"></p>
<p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</p>
<p>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态</p>
<h5 id="4-1-1-Serial-收集器"><a href="#4-1-1-Serial-收集器" class="headerlink" title="4.1.1 Serial 收集器"></a>4.1.1 Serial 收集器</h5><p>Serial收集器是最基本的、发展历史最悠久的收集器</p>
<p><strong>特点：</strong>单线程、简单高效（与其他收集器的单线程相比），采用<strong>复制算法</strong>。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p>
<h5 id="4-1-2-ParNew-收集器"><a href="#4-1-2-ParNew-收集器" class="headerlink" title="4.1.2 ParNew 收集器"></a>4.1.2 ParNew 收集器</h5><p>ParNew收集器其实就是Serial收集器的多线程版本</p>
<p><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p>
<h5 id="4-1-3-Serial-Old-收集器"><a href="#4-1-3-Serial-Old-收集器" class="headerlink" title="4.1.3 Serial Old 收集器"></a>4.1.3 Serial Old 收集器</h5><p>Serial Old是Serial收集器的老年代版本</p>
<p><strong>特点</strong>：同样是单线程收集器，采用<strong>标记-整理算法</strong></p>
<h4 id="4-2-吞吐量优先"><a href="#4-2-吞吐量优先" class="headerlink" title="4.2 吞吐量优先"></a>4.2 吞吐量优先</h4><ul>
<li>多线程</li>
<li>堆内存较大，多核CPU</li>
<li><strong>单位时间内</strong>，STW（stop the world，停掉其他所有工作线程）时间最短</li>
<li><strong>JDK1.8默认使用</strong>的垃圾回收器</li>
</ul>
<p><img src="/2022/12/17/JVM/20200608151039.png" alt="20200608151039"></p>
<h5 id="4-2-1-Parallel-Scavenge-收集器"><a href="#4-2-1-Parallel-Scavenge-收集器" class="headerlink" title="4.2.1 Parallel Scavenge 收集器"></a>4.2.1 Parallel Scavenge 收集器</h5><p>与吞吐量关系密切，故也称为吞吐量优先收集器</p>
<p><strong>特点</strong>：属于新生代收集器也是采用<strong>复制算法</strong>的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）</p>
<p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：<strong>GC自适应调节策略</strong>（与ParNew收集器最重要的一个区别）</p>
<p><strong>GC自适应调节策略</strong>：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p>
<p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p>
<ul>
<li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li>
<li>XX:GCRatio 直接设置吞吐量的大小</li>
</ul>
<h5 id="4-2-2-Parallel-Old-收集器"><a href="#4-2-2-Parallel-Old-收集器" class="headerlink" title="4.2.2 Parallel Old 收集器"></a>4.2.2 Parallel Old 收集器</h5><p>是Parallel Scavenge收集器的老年代版本</p>
<p><strong>特点</strong>：多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</p>
<h4 id="4-3-响应时间优先"><a href="#4-3-响应时间优先" class="headerlink" title="4.3 响应时间优先"></a>4.3 响应时间优先</h4><ul>
<li>多线程</li>
<li>堆内存较大，多核CPU</li>
<li>尽可能让单次STW时间变短（尽量不影响其他线程运行）</li>
</ul>
<p><img src="/2022/12/17/JVM/20200608151052.png" alt="20200608151052"></p>
<h5 id="4-3-1-CMS-收集器"><a href="#4-3-1-CMS-收集器" class="headerlink" title="4.3.1 CMS 收集器"></a>4.3.1 CMS 收集器</h5><p>Concurrent Mark Sweep，一种以获取<strong>最短回收停顿时间</strong>为目标的<strong>老年代</strong>收集器</p>
<p><strong>特点</strong>：基于<strong>标记-清除算法</strong>实现。并发收集、低停顿，但是会产生内存碎片</p>
<p><strong>应用场景</strong>：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b&#x2F;s服务</p>
<p><strong>CMS收集器的运行过程分为下列4步：</strong></p>
<p><strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快但是<strong>仍存在Stop The World问题</strong></p>
<p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p>
<p><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题</p>
<p><strong>并发清除</strong>：对标记的对象进行清除回收</p>
<p>CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的</p>
<h4 id="4-4-G1-❓"><a href="#4-4-G1-❓" class="headerlink" title="4.4 G1 ❓"></a>4.4 G1 ❓</h4><p>Garbage First</p>
<p>JDK 9以后默认使用，而且<strong>替代了CMS 收集器</strong></p>
<p><img src="/2022/12/17/JVM/20200909201212.png" alt="20200909201212"></p>
<h5 id="4-4-1-适用场景"><a href="#4-4-1-适用场景" class="headerlink" title="4.4.1 适用场景"></a>4.4.1 适用场景</h5><ul>
<li>同时注重吞吐量和低延迟（响应时间）</li>
<li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域</li>
<li>整体上是<strong>标记-整理</strong>算法，两个区域之间是<strong>复制</strong>算法</li>
</ul>
<p><strong>相关参数</strong>：JDK8 并不是默认开启的，所需要参数开启</p>
<p><img src="/2022/12/17/JVM/20200608151100.png" alt="20200608151100"></p>
<h5 id="4-4-2-G1垃圾回收阶段"><a href="#4-4-2-G1垃圾回收阶段" class="headerlink" title="4.4.2 G1垃圾回收阶段"></a>4.4.2 G1垃圾回收阶段</h5><p><img src="/2022/12/17/JVM/20200608151109.png" alt="20200608151109"></p>
<p>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记—–&gt;回收新生代伊甸园、幸存区、老年代内存——&gt;新生代伊甸园垃圾回收(重新开始)</p>
<h6 id="4-4-2-1-Young-Collection"><a href="#4-4-2-1-Young-Collection" class="headerlink" title="4.4.2.1 Young Collection"></a>4.4.2.1 Young Collection</h6><p><strong>分区算法region</strong></p>
<p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p>
<p>E：伊甸园 S：幸存区 O：老年代</p>
<ul>
<li>会STW</li>
</ul>
<p><img src="/2022/12/17/JVM/20200608151119.png" alt="20200608151119"></p>
<p><img src="/2022/12/17/JVM/20200608151129.png" alt="20200608151129"></p>
<p><img src="/2022/12/17/JVM/20200608151140.png" alt="20200608151140"></p>
<h6 id="4-4-2-2-Young-Collection-CM"><a href="#4-4-2-2-Young-Collection-CM" class="headerlink" title="4.4.2.2 Young Collection + CM"></a>4.4.2.2 Young Collection + CM</h6><p>CM：并发标记</p>
<ul>
<li>在 Young GC 时会<strong>对 GC Root 进行初始标记</strong></li>
<li>在老年代<strong>占用堆内存的比例</strong>达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定</li>
</ul>
<p><img src="/2022/12/17/JVM/20200608151150.png" alt="20200608151150"></p>
<h6 id="4-2-2-3-Mixed-Collection"><a href="#4-2-2-3-Mixed-Collection" class="headerlink" title="4.2.2.3 Mixed Collection"></a>4.2.2.3 Mixed Collection</h6><p>会对 E S O 进行<strong>全面的回收</strong></p>
<ul>
<li>最终标记</li>
<li><strong>拷贝</strong>存活</li>
</ul>
<p><code>-XX:MaxGCPauseMills:xxx</code> 用于指定最长的停顿时间</p>
<p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？</p>
<p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）</p>
<p><img src="/2022/12/17/JVM/20200608151201.png" alt="20200608151201"></p>
<h5 id="4-4-3-Full-GC"><a href="#4-4-3-Full-GC" class="headerlink" title="4.4.3 Full GC"></a>4.4.3 Full GC</h5><p><strong>对比</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- SerialGC</span><br><span class="line">-- 新生代内存不足发生的垃圾收集 - minor gc</span><br><span class="line">-- 老年代内存不足发生的垃圾收集 - full gc</span><br><span class="line"></span><br><span class="line">- ParallelGC</span><br><span class="line">-- 新生代内存不足发生的垃圾收集 - minor gc</span><br><span class="line">-- 老年代内存不足发生的垃圾收集 - full gc</span><br><span class="line"></span><br><span class="line">- CMS</span><br><span class="line">-- 新生代内存不足发生的垃圾收集 - minor gc</span><br><span class="line">-- 老年代内存不足</span><br><span class="line"></span><br><span class="line">- G1</span><br><span class="line">-- 新生代内存不足发生的垃圾收集 - minor gc</span><br><span class="line">-- 老年代内存不足</span><br></pre></td></tr></table></figure>

<p>G1在老年代内存不足时（老年代所占内存超过阈值）</p>
<ul>
<li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</li>
<li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</li>
</ul>
<h5 id="4-4-4-Young-Collection-跨代引用"><a href="#4-4-4-Young-Collection-跨代引用" class="headerlink" title="4.4.4 Young Collection 跨代引用"></a>4.4.4 Young Collection 跨代引用</h5><ul>
<li><p>新生代回收的跨代引用（老年代引用新生代）问题</p>
</li>
<li><p><img src="/2022/12/17/JVM/20200608151211.png" alt="20200608151211">卡表与Remembered Set</p>
<ul>
<li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡<ul>
<li>脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li>
</ul>
</li>
</ul>
</li>
<li><p>在引用变更时通过 post-write barried + dirty card queue</p>
</li>
<li><p>concurrent refinement threads 更新 Remembered Set</p>
</li>
</ul>
<p><img src="/2022/12/17/JVM/20200608151222.png" alt="20200608151222"></p>
<h5 id="4-4-5-Remark"><a href="#4-4-5-Remark" class="headerlink" title="4.4.5 Remark"></a>4.4.5 Remark</h5><p><strong>重新标记阶段</strong></p>
<p>在垃圾回收时，收集器处理对象的过程中</p>
<ul>
<li>黑色：已被处理，需要保留的 </li>
<li>灰色：正在处理中的</li>
<li>白色：还未处理的</li>
</ul>
<p><img src="/2022/12/17/JVM/20200608151229.png" alt="20200608151229"></p>
<p>但是在<strong>并发标记过程中</strong>，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用了C，这时就会用到remark</p>
<p>过程如下</p>
<ul>
<li>之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为 处理中 状态</li>
<li>在<strong>并发标记</strong>阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它</li>
</ul>
<p><img src="/2022/12/17/JVM/20200608151239.png" alt="20200608151239"></p>
<h5 id="4-4-6-JDK-8u20-字符串去重"><a href="#4-4-6-JDK-8u20-字符串去重" class="headerlink" title="4.4.6 JDK 8u20 字符串去重"></a>4.4.6 JDK 8u20 字符串去重</h5><p>默认开启 <code>-XX:+UseStringDeduplication</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>过程</p>
<ul>
<li>将所有新分配的字符串（底层是char[]）放入一个队列</li>
<li>当新生代回收时，G1并发检查是否有重复的字符串</li>
<li>如果字符串的值一样，就让他们<strong>引用同一个字符串对象</strong></li>
<li>注意，其与 String.intern 的区别<ul>
<li>intern关注的是字符串对象，StringTable(串池)</li>
<li>字符串去重关注的是char[]</li>
<li>在JVM内部，使用了不同的字符串标</li>
</ul>
</li>
</ul>
<p>优点与缺点</p>
<ul>
<li>节省了大量内存</li>
<li>新生代回收时间略微增加，导致略微多占用CPU</li>
</ul>
<h5 id="4-4-7-JDK-8u40-并发标记类卸载"><a href="#4-4-7-JDK-8u40-并发标记类卸载" class="headerlink" title="4.4.7 JDK 8u40 并发标记类卸载"></a>4.4.7 JDK 8u40 并发标记类卸载</h5><p>默认开启 <code>-XX:+ClassUnloadingWithConcurrentMark</code></p>
<p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p>
<h5 id="4-4-8-JDK-8u60-回收巨型对象"><a href="#4-4-8-JDK-8u60-回收巨型对象" class="headerlink" title="4.4.8 JDK 8u60 回收巨型对象"></a>4.4.8 JDK 8u60 回收巨型对象</h5><ul>
<li>一个对象大于region的一半时，就称为巨型对象</li>
<li>G1不会对巨型对象进行拷贝</li>
<li>回收时被优先考虑</li>
<li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li>
</ul>
<h5 id="4-4-9-JDK-9并发标记起始时间的调整"><a href="#4-4-9-JDK-9并发标记起始时间的调整" class="headerlink" title="4.4.9 JDK 9并发标记起始时间的调整"></a><img src="/2022/12/17/JVM/20200608151249.png" alt="20200608151249">4.4.9 JDK 9并发标记起始时间的调整</h5><ul>
<li>并发标记必须在对堆空间占满前完成，否则退化为FULLGC</li>
</ul>
<h3 id="5-GC-调优"><a href="#5-GC-调优" class="headerlink" title="5.GC 调优"></a>5.GC 调优</h3><p>查看虚拟机参数命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA/JDK8.0/bin/java -XX:+PrintFlagsFinal -version | findstr &quot;GC&quot;Copy</span><br></pre></td></tr></table></figure>

<p>可以根据参数去查询具体的信息</p>
<h4 id="5-1-调优领域"><a href="#5-1-调优领域" class="headerlink" title="5.1 调优领域"></a>5.1 调优领域</h4><ul>
<li>内存</li>
<li>锁竞争</li>
<li>CPU占用</li>
<li>IO</li>
<li>GC</li>
</ul>
<h4 id="5-2-确定目标"><a href="#5-2-确定目标" class="headerlink" title="5.2 确定目标"></a>5.2 确定目标</h4><p>低延迟 or 高吞吐量？ 选择合适的GC</p>
<ul>
<li>CMS G1 ZGC（低延迟）</li>
<li>ParallelGC（高吞吐量）</li>
<li>Zing（低延迟）</li>
</ul>
<h4 id="5-3-最快的GC是不发生GC"><a href="#5-3-最快的GC是不发生GC" class="headerlink" title="5.3 最快的GC是不发生GC"></a>5.3 最快的GC是不发生GC</h4><p>首先排除减少因为自身编写的代码而引发的内存问题</p>
<ul>
<li>查看Full GC前后的内存占用，考虑以下几个问题<ul>
<li>加载的内存数据太多？</li>
<li>数据表示是否太臃肿<ul>
<li>对象图</li>
<li>对象大小</li>
</ul>
</li>
<li>是否存在内存泄漏</li>
</ul>
</li>
</ul>
<h4 id="5-4-新生代调优"><a href="#5-4-新生代调优" class="headerlink" title="5.4 新生代调优"></a>5.4 新生代调优</h4><ul>
<li>新生代的特点<ul>
<li>所有的 new 操作分配内存都是非常廉价的<ul>
<li>TLAB（thread-local allocation buffer）</li>
</ul>
</li>
<li>死亡对象的回收代价是零</li>
<li>大部分对象用过即死（朝生夕死）</li>
<li>MInor GC 所用时间远小于 Full GC</li>
</ul>
</li>
<li>新生代内存越大越好么？<code>-Xmn</code><ul>
<li>不是</li>
<li>存在的问题<ul>
<li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li>
<li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li>
<li>Oracle：$25%heap\space size\lt generation\lt 50%heap\space size $</li>
</ul>
</li>
<li>新生代内存设置为能容纳 <code>[并发量*(请求-响应)]</code> 的数据为宜</li>
</ul>
</li>
</ul>
<h4 id="5-5-幸存区调优"><a href="#5-5-幸存区调优" class="headerlink" title="5.5 幸存区调优"></a>5.5 幸存区调优</h4><ul>
<li>幸存区需要能够保存 <code>当前活跃对象+需要晋升的对象</code></li>
<li>晋升阈值配置得当，让长时间存活的对象尽快晋升<ul>
<li><code>-XX:MaxTenuringThreshold=threshold</code></li>
<li>希望让生命周期短的对象通过 minor gc 回收，而不是晋升至老年代</li>
</ul>
</li>
</ul>
<h4 id="5-6-老年代调优"><a href="#5-6-老年代调优" class="headerlink" title="5.6 老年代调优"></a>5.6 老年代调优</h4><p>以 CMS 为例</p>
<ul>
<li>CMS的老年代内存越大越好</li>
<li>老年代调优之前先尝试不进行调优<ul>
<li>等待一段时间，若没有发生 FULL GC，说明老年代的内存已经足够大，尝试先调试新生代</li>
</ul>
</li>
<li>观察发生 FULL GC的老年代内存占用，讲老年代内存预设调大 $\frac{1}{4} \sim \frac{1}{3}$<ul>
<li><code>-XX:CMSInitaiatingOccupancyFraction=percent</code></li>
</ul>
</li>
</ul>
<h4 id="5-7-GC调优的案例"><a href="#5-7-GC调优的案例" class="headerlink" title="5.7 GC调优的案例"></a>5.7 GC调优的案例</h4><ul>
<li>案例1，FULL GC 和 Minor GC 频繁<ul>
<li>增大新生代的内存</li>
</ul>
</li>
<li>案例2，请求高峰期发生 FULL GC，单次暂停时间特别长（CMS）<ul>
<li>业务需要低延迟，单次暂停时间特别长</li>
<li>发现是重新标记阶段时间过长，在重新标记之前对新生代做垃圾清理 <code>-XX:+CMSScavengeBeforeRemark</code></li>
</ul>
</li>
<li>案例3，老年代充裕情况下，发生 FULL GC（JDK1.7）<ul>
<li>方法区采用永久代（非元空间），永久代的空间不足</li>
</ul>
</li>
</ul>
<h2 id="类加载与字节码技术"><a href="#类加载与字节码技术" class="headerlink" title="类加载与字节码技术"></a>类加载与字节码技术</h2><p><img src="/2022/12/17/JVM/20200608151300.png" alt="20200608151300"></p>
<h3 id="1-类文件结构"><a href="#1-类文件结构" class="headerlink" title="1.类文件结构"></a>1.类文件结构</h3><h4 id="1-1-HelloWorld-java"><a href="#1-1-HelloWorld-java" class="headerlink" title="1.1 HelloWorld.java"></a>1.1 HelloWorld.java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 <code>javac -parameters -d . HelloWorld.java </code> ，生成 HelloWorld.class</p>
<p>执行 <code>od -t xC HelloWorld.class</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 </span><br><span class="line">0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 </span><br><span class="line">0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 </span><br><span class="line">0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e </span><br><span class="line">0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63 </span><br><span class="line">0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 </span><br><span class="line">0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63 </span><br><span class="line">0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f </span><br><span class="line">0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16 </span><br><span class="line">0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 </span><br><span class="line">0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 </span><br><span class="line">0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 </span><br><span class="line">0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61 </span><br><span class="line">0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46 </span><br><span class="line">0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</span><br><span class="line">0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e </span><br><span class="line">0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 </span><br><span class="line">0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 </span><br><span class="line">0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c </span><br><span class="line">0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61 </span><br><span class="line">0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61 </span><br><span class="line">0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f </span><br><span class="line">0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 </span><br><span class="line">0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76 </span><br><span class="line">0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d </span><br><span class="line">0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a </span><br><span class="line">0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b </span><br><span class="line">0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 </span><br><span class="line">0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01 </span><br><span class="line">0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00 </span><br><span class="line">0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 </span><br><span class="line">0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00 </span><br><span class="line">0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00 </span><br><span class="line">0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a </span><br><span class="line">0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b </span><br><span class="line">0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00 </span><br><span class="line">0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00 </span><br><span class="line">0001120 00 00 02 00 14</span><br></pre></td></tr></table></figure>

<p>根据 JVM 规范，<strong>类文件结构</strong>如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ClassFile&#123;</span><br><span class="line">u4 			 			 magic</span><br><span class="line">u2             minor_version;    </span><br><span class="line">u2             major_version;    </span><br><span class="line">u2             constant_pool_count;    </span><br><span class="line">cp_info        constant_pool[constant_pool_count-1];    </span><br><span class="line">u2             access_flags;    </span><br><span class="line">u2             this_class;    </span><br><span class="line">u2             super_class;   </span><br><span class="line">u2             interfaces_count;    </span><br><span class="line">u2             interfaces[interfaces_count];   </span><br><span class="line">u2             fields_count;    </span><br><span class="line">field_info     fields[fields_count];   </span><br><span class="line">u2             methods_count;    </span><br><span class="line">method_info    methods[methods_count];    </span><br><span class="line">u2             attributes_count;    </span><br><span class="line">attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-魔数"><a href="#1-2-魔数" class="headerlink" title="1.2 魔数"></a>1.2 魔数</h4><p><code>u4 magic</code></p>
<p>字节码文件的0～3字节</p>
<p>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p>
<h4 id="1-2-版本"><a href="#1-2-版本" class="headerlink" title="1.2 版本"></a>1.2 版本</h4><p><code>u2 minor_version</code></p>
<p><code>u2 major_version</code></p>
<p>字节码文件的4～7字节</p>
<p>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09</p>
<p>00 34（52）代表 JDK8</p>
<h4 id="1-3-常量池"><a href="#1-3-常量池" class="headerlink" title="1.3 常量池"></a>1.3 常量池</h4><p>字节码文件的8～9字节</p>
<p>0000000 ca fe ba be 00 00 00 34 <strong>00 23</strong> 0a 00 06 00 15 09</p>
<p>00 23（35）表示常量池有 #1～#34 项，注意 #0 项不计入，也没有值</p>
<ul>
<li>第 #1 项和 0a 代表一个 Method 信息，00 06 和 00 15（21）表示它引用了常量池中 #6 和 #21 项来获得这个方法的 [所属类] 和 [方法名]<ul>
<li><code>00000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09</code></li>
</ul>
</li>
<li>第 #2 项 09 表示一个 Filed信息，00 16（22）和 00 17（23） 表示引用常量池中 #22 和 #23项来获得这个方法的 [所属类] 和 [方法名]<ul>
<li><code>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07</code></li>
</ul>
</li>
<li>第 #3 项 08 表示一个字符串常量名称，00 18（24）表示引用了常量池中 #24 项<ul>
<li><code>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07</code></li>
</ul>
</li>
<li>$…$</li>
<li>第 #7 项 01 表示一个 utf8 串，00 06 表示长度，3c 69 6e 74 3e是 [&lt;init&gt;]<ul>
<li><code>0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29  </code></li>
</ul>
</li>
</ul>
<h3 id="2-字节码指令"><a href="#2-字节码指令" class="headerlink" title="2.字节码指令"></a>2.字节码指令</h3><h4 id="2-1-参考：Oracle-JVM"><a href="#2-1-参考：Oracle-JVM" class="headerlink" title="2.1 参考：Oracle-JVM"></a>2.1 参考：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">Oracle-JVM</a></h4><ul>
<li>init</li>
<li>main</li>
</ul>
<h4 id="2-2-javap工具"><a href="#2-2-javap工具" class="headerlink" title="2.2 javap工具"></a>2.2 javap工具</h4><p>Oracle 提供了 <strong>javap</strong> 工具来反编译 class 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javap -v Main.classCopy</span><br><span class="line">javap -v HelloWorld.class</span><br><span class="line">Classfile .class</span><br><span class="line">  Last modified 2020-6-6; size 434 bytes</span><br><span class="line">  MD5 checksum df1dce65bf6fb0b4c1de318051f4a67e</span><br><span class="line">  Compiled from &quot;HelloWorld.java&quot;</span><br><span class="line">public class com.nyima.JVM.day5.HelloWorld</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#15         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #16.#17        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #18            // hello world</span><br><span class="line">   #4 = Methodref          #19.#20        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #21            // com/nyima/JVM/day5/Demo1</span><br><span class="line">   #6 = Class              #22            // java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               main</span><br><span class="line">  #12 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #13 = Utf8               SourceFile</span><br><span class="line">  #14 = Utf8               Demo1.java</span><br><span class="line">  #15 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #16 = Class              #23            // java/lang/System</span><br><span class="line">  #17 = NameAndType        #24:#25        // out:Ljava/io/PrintStream;</span><br><span class="line">  #18 = Utf8               hello world</span><br><span class="line">  #19 = Class              #26            // java/io/PrintStream</span><br><span class="line">  #20 = NameAndType        #27:#28        // println:(Ljava/lang/String;)V</span><br><span class="line">  #21 = Utf8               com/nyima/JVM/day5/Demo1</span><br><span class="line">  #22 = Utf8               java/lang/Object</span><br><span class="line">  #23 = Utf8               java/lang/System</span><br><span class="line">  #24 = Utf8               out</span><br><span class="line">  #25 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #26 = Utf8               java/io/PrintStream</span><br><span class="line">  #27 = Utf8               println</span><br><span class="line">  #28 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public com.nyima.JVM.day5.HelloWorld();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String hello world</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 9: 0</span><br><span class="line">        line 10: 8</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<h4 id="2-3-图解方法执行流程"><a href="#2-3-图解方法执行流程" class="headerlink" title="2.3 图解方法执行流程"></a>2.3 图解方法执行流程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3_1</span> &#123;    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        </span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;        </span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Short.MAX_VALUE + <span class="number">1</span>;        </span><br><span class="line">		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;        </span><br><span class="line">		System.out.println(c);   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p><strong>常量池载入运行时常量池</strong></p>
<p>常量池也属于方法区，class文件常量池文件存储在运行时常量池</p>
<p><img src="/2022/12/17/JVM/20200608151317.png" alt="20200608151317"></p>
<p><strong>方法字节码载入方法区</strong></p>
<p><strong>main线程开始运行，分配栈帧内存</strong></p>
<p>（stack&#x3D;2，locals&#x3D;4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p>
<p><img src="/2022/12/17/JVM/20200608151325.png" alt="20200608151325"></p>
<p><strong>执行引擎开始执行字节码</strong></p>
<p><strong>bipush 10</strong></p>
<ul>
<li><p>将一个 byte 压入操作数栈，（其长度会补齐 4 个字节），类似的指令还有</p>
<ul>
<li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li>
<li>ldc 将一个 int 压入操作数栈</li>
<li>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</li>
<li>这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></li>
</ul>
</li>
</ul>
<p><img src="/2022/12/17/JVM/20200608151336.png" alt="20200608151336"></p>
<p><strong>istore 1</strong></p>
<p>将操作数栈栈顶元素弹出，放入局部变量表的 slot 1 中</p>
<p>对应代码中的 <code>a = 10</code></p>
<p><img src="/2022/12/17/JVM/20200608151346.png" alt="20200608151346"></p>
<p><img src="/2022/12/17/JVM/20200608151412.png" alt="20200608151412"></p>
<p><strong>ldc #3</strong></p>
<p>读取运行时常量池中#3，即32768（超过short最大值范围的数会被放到运行时常量池中），将其加载到操作数栈中</p>
<p>注意 Short.MAX_VALUE 是 32767，所以 32768 &#x3D; Short.MAX_VALUE + 1 实际是在编译期间计算好的</p>
<p><img src="/2022/12/17/JVM/20200608151421.png" alt="20200608151421"></p>
<p><strong>istore 2</strong></p>
<p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p>
<p><img src="/2022/12/17/JVM/20200608151432.png" alt="20200608151432"></p>
<p><img src="/2022/12/17/JVM/20200608151441.png" alt="20200608151441"></p>
<p><strong>iload1 iload2</strong></p>
<p>将局部变量表中1号位置和2号位置的元素放入操作数栈中</p>
<ul>
<li>因为只能在操作数栈中执行运算操作</li>
</ul>
<p><img src="/2022/12/17/JVM/20200608151450.png" alt="20200608151450"></p>
<p><img src="/2022/12/17/JVM/20200608151459.png" alt="20200608151459"></p>
<p><strong>iadd</strong></p>
<p>将操作数栈中的两个元素<strong>弹出栈</strong>并相加，结果在压入操作数栈中</p>
<p><img src="/2022/12/17/JVM/20200608151508.png" alt="20200608151508"></p>
<p><img src="/2022/12/17/JVM/20200608151523.png" alt="20200608151523"></p>
<p><strong>istore 3</strong></p>
<p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p>
<p><img src="/2022/12/17/JVM/20200608151547.png" alt="20200608151547"></p>
<p><img src="/2022/12/17/JVM/20200608151555.png" alt="20200608151555"></p>
<p><strong>getstatic #4</strong></p>
<p>在运行时常量池中找到#4，发现是一个对象</p>
<p>在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</p>
<p><img src="/2022/12/17/JVM/20200608151605.png" alt="20200608151605"></p>
<p><img src="/2022/12/17/JVM/20200608151613.png" alt="20200608151613"></p>
<p><strong>iload 3</strong></p>
<p>将局部变量表中3号位置的元素压入操作数栈中</p>
<p><img src="/2022/12/17/JVM/20200608151624.png" alt="20200608151624"></p>
<p><strong>invokevirtual 5</strong></p>
<p>找到常量池 #5 项，定位到方法区 java&#x2F;io&#x2F;PrintStream.println:(I)V 方法</p>
<p>生成新的栈帧（分配 locals、stack等）</p>
<p>传递参数，执行新栈帧中的字节码</p>
<p><img src="/2022/12/17/JVM/20200608151632.png" alt="20200608151632"></p>
<p>执行完毕，弹出栈帧</p>
<p>清除 main 操作数栈内容</p>
<p><img src="/2022/12/17/JVM/20200608151640.png" alt="20200608151640"></p>
<p><strong>return</strong><br>完成 main 方法调用，弹出 main 栈帧，程序结束</p>
<p><strong>练习：分析a++（p112）</strong></p>
<h4 id="2-4-字节码指令"><a href="#2-4-字节码指令" class="headerlink" title="2.4 字节码指令"></a>2.4 字节码指令</h4><h5 id="2-4-1-条件判断"><a href="#2-4-1-条件判断" class="headerlink" title="2.4.1 条件判断"></a>2.4.1 条件判断</h5><h5 id="2-4-2-循环控制"><a href="#2-4-2-循环控制" class="headerlink" title="2.4.2 循环控制"></a>2.4.2 循环控制</h5><p><strong>练习：分析x &#x3D; 0</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">			x = x++;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(x); <span class="comment">// x = 0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>为什么最终的x结果为0呢？ 通过分析字节码指令即可知晓</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=2, locals=3, args_size=1	//操作数栈分配2个空间，局部变量表分配3个空间</span><br><span class="line">        0: iconst_0	//准备一个常数0</span><br><span class="line">        1: istore_1	//将常数0放入局部变量表的1号槽位 i=0</span><br><span class="line">        2: iconst_0	//准备一个常数0</span><br><span class="line">        3: istore_2	//将常数0放入局部变量的2号槽位 x=0	</span><br><span class="line">        4: iload_1		//将局部变量表1号槽位的数放入操作数栈中</span><br><span class="line">        5: bipush        10	//将数字10放入操作数栈中，此时操作数栈中有2个数</span><br><span class="line">        7: if_icmpge     21	//比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到21。这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空</span><br><span class="line">       10: iload_2		//将局部变量2号槽位的数放入操作数栈中，放入的值是0</span><br><span class="line">       11: iinc          2, 1	//将局部变量2号槽位的数加1，自增后，槽位中的值为1</span><br><span class="line">       14: istore_2	//将操作数栈中的数放入到局部变量表的2号槽位，2号槽位的值又变为了0</span><br><span class="line">       15: iinc          1, 1 //1号槽位的值自增1</span><br><span class="line">       18: goto          4 //跳转到第4条指令</span><br><span class="line">       21: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       24: iload_2</span><br><span class="line">       25: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">       28: returnCopy</span><br></pre></td></tr></table></figure>

<h5 id="2-4-3-构造方法"><a href="#2-4-3-构造方法" class="headerlink" title="2.4.3 构造方法"></a>2.4.3 构造方法</h5><ul>
<li><strong>cinit()</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		i = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		i = <span class="number">30</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(i); <span class="comment">//结果为30</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会按<strong>从上至下</strong>的顺序，收集所有 static 静态代码块和静态成员赋值的代码，<strong>合并</strong>为一个特殊的方法 <strong>cinit()V</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack=1, locals=0, args_size=0</span><br><span class="line">         0: bipush        10</span><br><span class="line">         2: putstatic     #3                  // Field i:I</span><br><span class="line">         5: bipush        20</span><br><span class="line">         7: putstatic     #3                  // Field i:I</span><br><span class="line">        10: bipush        30</span><br><span class="line">        12: putstatic     #3                  // Field i:I</span><br><span class="line">        15: returnCopy</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>init()</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;s1&quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		b = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		a = <span class="string">&quot;s2&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Demo4</span><span class="params">(String a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.a = a;</span><br><span class="line">		<span class="built_in">this</span>.b = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Demo4</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo4</span>(<span class="string">&quot;s3&quot;</span>, <span class="number">30</span>);</span><br><span class="line">		System.out.println(d.a); <span class="comment">// &quot;s3&quot;</span></span><br><span class="line">		System.out.println(d.b); <span class="comment">// 30</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会按<strong>从上至下</strong>的顺序，收集所有 {} 代码块和成员变量赋值的代码，<strong>形成新的构造方法</strong>，但<strong>原始构造方法</strong>内的代码<strong>总是在后</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=2, locals=3, args_size=3</span><br><span class="line">        0: aload_0</span><br><span class="line">        1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        4: aload_0</span><br><span class="line">        5: ldc           #2                  // String s1</span><br><span class="line">        7: putfield      #3                  // Field a:Ljava/lang/String;</span><br><span class="line">       10: aload_0</span><br><span class="line">       11: bipush        20</span><br><span class="line">       13: putfield      #4                  // Field b:I</span><br><span class="line">       16: aload_0</span><br><span class="line">       17: bipush        10</span><br><span class="line">       19: putfield      #4                  // Field b:I</span><br><span class="line">       22: aload_0</span><br><span class="line">       23: ldc           #5                  // String s2</span><br><span class="line">       25: putfield      #3                  // Field a:Ljava/lang/String;</span><br><span class="line">       //原始构造方法在最后执行</span><br><span class="line">       28: aload_0</span><br><span class="line">       29: aload_1</span><br><span class="line">       30: putfield      #3                  // Field a:Ljava/lang/String;</span><br><span class="line">       33: aload_0</span><br><span class="line">       34: iload_2</span><br><span class="line">       35: putfield      #4                  // Field b:I</span><br><span class="line">       38: returnCopy</span><br></pre></td></tr></table></figure>

<h4 id="2-5-方法调用"><a href="#2-5-方法调用" class="headerlink" title="2.5 方法调用"></a>2.5 方法调用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo5 &#123;</span><br><span class="line">	public Demo5() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void test1() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private final void test2() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void test3() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void test4() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Demo5 demo5 = new Demo5();</span><br><span class="line">		demo5.test1();</span><br><span class="line">		demo5.test2();</span><br><span class="line">		demo5.test3();</span><br><span class="line">		Demo5.test4();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>不同方法在调用时，对应的虚拟机指令有所区别</p>
<ul>
<li>私有、构造、被final修饰的方法，在调用时都使用<strong>invokespecial</strong>指令</li>
<li>普通成员方法在调用时，使用invokespecial指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定</li>
<li>静态方法在调用时使用invokestatic指令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">      stack=2, locals=2, args_size=1</span><br><span class="line">         0: new           #2                  // class com/nyima/JVM/day5/Demo5 </span><br><span class="line">         3: dup</span><br><span class="line">         4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         7: astore_1</span><br><span class="line">         8: aload_1</span><br><span class="line">         9: invokespecial #4                  // Method test1:()V</span><br><span class="line">        12: aload_1</span><br><span class="line">        13: invokespecial #5                  // Method test2:()V</span><br><span class="line">        16: aload_1</span><br><span class="line">        17: invokevirtual #6                  // Method test3:()V</span><br><span class="line">        20: invokestatic  #7                  // Method test4:()V</span><br><span class="line">        23: returnCopy</span><br></pre></td></tr></table></figure>

<ul>
<li>new 是创建【对象】，给对象分配堆内存，执行成功会将【<strong>对象引用</strong>】压入操作数栈</li>
<li>dup 是赋值操作数栈栈顶的内容，本例即为【<strong>对象引用</strong>】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 “init”:()V （会消耗掉栈顶一个引用），另一个要 配合 astore_1 赋值给局部变量</li>
<li>终方法（ﬁnal），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定</li>
<li>普通成员方法是由 invokevirtual 调用，属于<strong>动态绑定</strong>，即支持多态 成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】</li>
</ul>
<h4 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h4><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用<strong>invokevirtual</strong>指令</p>
<p>在执行invokevirtual指令时，经历了以下几个步骤</p>
<ul>
<li>先通过栈帧中对象的引用找到对象</li>
<li>分析对象头，找到对象实际的Class</li>
<li>Class结构中有<strong>vtable</strong></li>
<li>查询vtable找到方法的具体地址</li>
<li>执行方法的字节码</li>
</ul>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int i = 0;</span><br><span class="line">		try &#123;</span><br><span class="line">			i = 10;</span><br><span class="line">		&#125;catch (Exception e) &#123;</span><br><span class="line">			i = 20;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>对应字节码指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=1, locals=3, args_size=1</span><br><span class="line">        0: iconst_0</span><br><span class="line">        1: istore_1</span><br><span class="line">        2: bipush        10</span><br><span class="line">        4: istore_1</span><br><span class="line">        5: goto          12</span><br><span class="line">        8: astore_2</span><br><span class="line">        9: bipush        20</span><br><span class="line">       11: istore_1</span><br><span class="line">       12: return</span><br><span class="line">     //多出来一个异常表</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            2     5     8   Class java/lang/ExceptionCopy</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到多出来一个 Exception table 的结构，[from, to) 是<strong>前闭后开</strong>（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</li>
<li>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）</li>
</ul>
<h5 id="多个single-catch"><a href="#多个single-catch" class="headerlink" title="多个single-catch"></a>多个single-catch</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int i = 0;</span><br><span class="line">		try &#123;</span><br><span class="line">			i = 10;</span><br><span class="line">		&#125;catch (ArithmeticException e) &#123;</span><br><span class="line">			i = 20;</span><br><span class="line">		&#125;catch (Exception e) &#123;</span><br><span class="line">			i = 30;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>对应的字节码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=1, locals=3, args_size=1</span><br><span class="line">        0: iconst_0</span><br><span class="line">        1: istore_1</span><br><span class="line">        2: bipush        10</span><br><span class="line">        4: istore_1</span><br><span class="line">        5: goto          19</span><br><span class="line">        8: astore_2</span><br><span class="line">        9: bipush        20</span><br><span class="line">       11: istore_1</span><br><span class="line">       12: goto          19</span><br><span class="line">       15: astore_2</span><br><span class="line">       16: bipush        30</span><br><span class="line">       18: istore_1</span><br><span class="line">       19: return</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            2     5     8   Class java/lang/ArithmeticException</span><br><span class="line">            2     5    15   Class java/lang/ExceptionCopy</span><br></pre></td></tr></table></figure>

<ul>
<li>因为异常出现时，<strong>只能进入</strong> Exception table 中<strong>一个分支</strong>，所以局部变量表 slot 2 位置<strong>被共用</strong></li>
</ul>
<h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int i = 0;</span><br><span class="line">		try &#123;</span><br><span class="line">			i = 10;</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			i = 20;</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			i = 30;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=1, locals=4, args_size=1</span><br><span class="line">        0: iconst_0</span><br><span class="line">        1: istore_1</span><br><span class="line">        //try块</span><br><span class="line">        2: bipush        10</span><br><span class="line">        4: istore_1</span><br><span class="line">        //try块执行完后，会执行finally    </span><br><span class="line">        5: bipush        30</span><br><span class="line">        7: istore_1</span><br><span class="line">        8: goto          27</span><br><span class="line">       //catch块     </span><br><span class="line">       11: astore_2 //异常信息放入局部变量表的2号槽位</span><br><span class="line">       12: bipush        20</span><br><span class="line">       14: istore_1</span><br><span class="line">       //catch块执行完后，会执行finally        </span><br><span class="line">       15: bipush        30</span><br><span class="line">       17: istore_1</span><br><span class="line">       18: goto          27</span><br><span class="line">       //出现异常，但未被Exception捕获，会抛出其他异常，这时也需要执行finally块中的代码   </span><br><span class="line">       21: astore_3</span><br><span class="line">       22: bipush        30</span><br><span class="line">       24: istore_1</span><br><span class="line">       25: aload_3</span><br><span class="line">       26: athrow  //抛出异常</span><br><span class="line">       27: return</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            2     5    11   Class java/lang/Exception</span><br><span class="line">            2     5    21   any</span><br><span class="line">           11    15    21   anyCopy</span><br></pre></td></tr></table></figure>

<p>可以看到 ﬁnally 中的代码被<strong>复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch剩余的异常类型流程</p>
<p><strong>注意</strong>：虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码<strong>只会被执行一次</strong></p>
<h5 id="finally中的return"><a href="#finally中的return" class="headerlink" title="finally中的return"></a>finally中的return</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo3 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int i = Demo3.test();</span><br><span class="line">        //结果为20</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static int test() &#123;</span><br><span class="line">		int i;</span><br><span class="line">		try &#123;</span><br><span class="line">			i = 10;</span><br><span class="line">			return i;</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			i = 20;</span><br><span class="line">			return i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=1, locals=3, args_size=0</span><br><span class="line">        0: bipush        10</span><br><span class="line">        2: istore_0</span><br><span class="line">        3: iload_0</span><br><span class="line">        4: istore_1  //暂存返回值</span><br><span class="line">        5: bipush        20</span><br><span class="line">        7: istore_0</span><br><span class="line">        8: iload_0</span><br><span class="line">        9: ireturn	//ireturn会返回操作数栈顶的整型值20</span><br><span class="line">       //如果出现异常，还是会执行finally块中的内容，没有抛出异常</span><br><span class="line">       10: astore_2</span><br><span class="line">       11: bipush        20</span><br><span class="line">       13: istore_0</span><br><span class="line">       14: iload_0</span><br><span class="line">       15: ireturn	//这里没有athrow了，也就是如果在finally块中如果有返回操作的话，且try块中出现异常，会吞掉异常！</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            0     5    10   anyCopy</span><br></pre></td></tr></table></figure>

<ul>
<li>由于 ﬁnally 中的 <strong>ireturn</strong> 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准</li>
<li>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子</li>
<li>跟上例中的 ﬁnally 相比，发现<strong>没有 athrow 了</strong>，这告诉我们：如果在 ﬁnally 中出现了 return，会<strong>吞掉异常</strong></li>
<li>所以<strong>不要在finally中进行返回操作</strong></li>
</ul>
<h5 id="被吞掉的异常"><a href="#被吞掉的异常" class="headerlink" title="被吞掉的异常"></a>被吞掉的异常</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo3 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      int i = Demo3.test();</span><br><span class="line">      //最终结果为20</span><br><span class="line">      System.out.println(i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static int test() &#123;</span><br><span class="line">      int i;</span><br><span class="line">      try &#123;</span><br><span class="line">         i = 10;</span><br><span class="line">         //这里应该会抛出异常</span><br><span class="line">         i = i/0;</span><br><span class="line">         return i;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">         i = 20;</span><br><span class="line">         return i;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>会发现打印结果为20，并未抛出异常</p>
<h5 id="finally不带return"><a href="#finally不带return" class="headerlink" title="finally不带return"></a>finally不带return</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo4 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int i = Demo4.test();</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static int test() &#123;</span><br><span class="line">		int i = 10;</span><br><span class="line">		try &#123;</span><br><span class="line">			return i;</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			i = 20;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=1, locals=3, args_size=0</span><br><span class="line">        0: bipush        10</span><br><span class="line">        2: istore_0 //赋值给i 10</span><br><span class="line">        3: iload_0	//加载到操作数栈顶</span><br><span class="line">        4: istore_1 //加载到局部变量表的1号位置</span><br><span class="line">        5: bipush        20</span><br><span class="line">        7: istore_0 //赋值给i 20</span><br><span class="line">        8: iload_1 //加载局部变量表1号位置的数10到操作数栈</span><br><span class="line">        9: ireturn //返回操作数栈顶元素 10</span><br><span class="line">       10: astore_2</span><br><span class="line">       11: bipush        20</span><br><span class="line">       13: istore_0</span><br><span class="line">       14: aload_2 //加载异常</span><br><span class="line">       15: athrow //抛出异常</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            3     5    10   anyCopy</span><br></pre></td></tr></table></figure>

<h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo5 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int i = 10;</span><br><span class="line">		Lock lock = new Lock();</span><br><span class="line">		synchronized (lock) &#123;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Lock&#123;&#125;Copy</span><br></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=2, locals=5, args_size=1</span><br><span class="line">        0: bipush        10</span><br><span class="line">        2: istore_1</span><br><span class="line">        3: new           #2                  // class com/nyima/JVM/day06/Lock</span><br><span class="line">        6: dup //复制一份，放到操作数栈顶，用于构造函数消耗</span><br><span class="line">        7: invokespecial #3                  // Method com/nyima/JVM/day06/Lock.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       10: astore_2 //剩下的一份放到局部变量表的2号位置</span><br><span class="line">       11: aload_2 //加载到操作数栈</span><br><span class="line">       12: dup //复制一份，放到操作数栈，用于加锁时消耗</span><br><span class="line">       13: astore_3 //将操作数栈顶元素弹出，暂存到局部变量表的三号槽位。这时操作数栈中有一份对象的引用</span><br><span class="line">       14: monitorenter //加锁</span><br><span class="line">       //锁住后代码块中的操作    </span><br><span class="line">       15: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       18: iload_1</span><br><span class="line">       19: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">       //加载局部变量表中三号槽位对象的引用，用于解锁    </span><br><span class="line">       22: aload_3    </span><br><span class="line">       23: monitorexit //解锁</span><br><span class="line">       24: goto          34</span><br><span class="line">       //异常操作    </span><br><span class="line">       27: astore        4</span><br><span class="line">       29: aload_3</span><br><span class="line">       30: monitorexit //解锁</span><br><span class="line">       31: aload         4</span><br><span class="line">       33: athrow</span><br><span class="line">       34: return</span><br><span class="line">     //可以看出，无论何时出现异常，都会跳转到27行，将异常放入局部变量中，并进行解锁操作，然后加载异常并抛出异常。      </span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">           15    24    27   any</span><br><span class="line">           27    31    27   anyCopy</span><br></pre></td></tr></table></figure>

<h3 id="3、编译期处理"><a href="#3、编译期处理" class="headerlink" title="3、编译期处理"></a>3、编译期处理</h3><p>所谓的 <strong>语法糖</strong> ，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，<strong>自动生成</strong>和<strong>转换</strong>的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</p>
<p><strong>注意</strong>，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的<strong>结果直接就是 class 字节码</strong>，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p>
<h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Candy1 &#123;</span><br><span class="line"></span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>经过编译期优化后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Candy1 &#123;</span><br><span class="line">   //这个无参构造器是java编译器帮我们加上的</span><br><span class="line">   public Candy1() &#123;</span><br><span class="line">      //即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V</span><br><span class="line">      super();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<h4 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h4><p>基本类型和其包装类型的相互转换过程，称为拆装箱</p>
<p>在JDK 5以后，它们的转换可以在编译期自动完成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Integer x = 1;</span><br><span class="line">      int y = x;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>转换过程如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      //基本类型赋值给包装类型，称为装箱</span><br><span class="line">      Integer x = Integer.valueOf(1);</span><br><span class="line">      //包装类型赋值给基本类型，称谓拆箱</span><br><span class="line">      int y = x.intValue();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<h4 id="泛型集合取值"><a href="#泛型集合取值" class="headerlink" title="泛型集合取值"></a>泛型集合取值</h4><p>泛型也是在 JDK 5 开始加入的特性，但 java 在<strong>编译泛型代码后</strong>会执行 <strong>泛型擦除</strong> 的动作，即泛型信息在编译为字节码之后就<strong>丢失</strong>了，实际的类型都当做了 <strong>Object</strong> 类型来处理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo3 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">      list.add(10);</span><br><span class="line">      Integer x = list.get(0);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">    stack=2, locals=3, args_size=1</span><br><span class="line">       0: new           #2                  // class java/util/ArrayList</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #3                  // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: astore_1</span><br><span class="line">       8: aload_1</span><br><span class="line">       9: bipush        10</span><br><span class="line">      11: invokestatic  #4                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">      //这里进行了泛型擦除，实际调用的是add(Objcet o)</span><br><span class="line">      14: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span><br><span class="line"></span><br><span class="line">      19: pop</span><br><span class="line">      20: aload_1</span><br><span class="line">      21: iconst_0</span><br><span class="line">      //这里也进行了泛型擦除，实际调用的是get(Object o)   </span><br><span class="line">      22: invokeinterface #6,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;</span><br><span class="line">//这里进行了类型转换，将Object转换成了Integer</span><br><span class="line">      27: checkcast     #7                  // class java/lang/Integer</span><br><span class="line">      30: astore_2</span><br><span class="line">      31: returnCopy</span><br></pre></td></tr></table></figure>

<p>所以调用get函数取值时，有一个类型转换的操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer x = (Integer) list.get(0);Copy</span><br></pre></td></tr></table></figure>

<p>如果要将返回结果赋值给一个int类型的变量，则还有<strong>自动拆箱</strong>的操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int x = (Integer) list.get(0).intValue();Copy</span><br></pre></td></tr></table></figure>

<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo4 &#123;</span><br><span class="line">   public static void foo(String... args) &#123;</span><br><span class="line">      //将args赋值给arr，可以看出String...实际就是String[] </span><br><span class="line">      String[] arr = args;</span><br><span class="line">      System.out.println(arr.length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      foo(&quot;hello&quot;, &quot;world&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>可变参数 <strong>String…</strong> args 其实是一个 <strong>String[]</strong> args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo4 &#123;</span><br><span class="line">   public Demo4 &#123;&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">   public static void foo(String[] args) &#123;</span><br><span class="line">      String[] arr = args;</span><br><span class="line">      System.out.println(arr.length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      foo(new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>注意，如果调用的是foo()，即未传递参数时，等价代码为foo(new String[]{})，<strong>创建了一个空数组</strong>，而不是直接传递的null</p>
<h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo5 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">        //数组赋初值的简化写法也是一种语法糖。</span><br><span class="line">		int[] arr = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">		for(int x : arr) &#123;</span><br><span class="line">			System.out.println(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>编译器会帮我们转换为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo5 &#123;</span><br><span class="line">    public Demo5 &#123;&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[] arr = new int[]&#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">		for(int i=0; i&lt;arr.length; ++i) &#123;</span><br><span class="line">			int x = arr[i];</span><br><span class="line">			System.out.println(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p><strong>如果是集合使用foreach</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo5 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);</span><br><span class="line">      for (Integer x : list) &#123;</span><br><span class="line">         System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>集合要使用foreach，需要该集合类实现了<strong>Iterable接口</strong>，因为集合的遍历需要用到<strong>迭代器Iterator</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo5 &#123;</span><br><span class="line">    public Demo5 &#123;&#125;</span><br><span class="line">    </span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);</span><br><span class="line">      //获得该集合的迭代器</span><br><span class="line">      Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">      while(iterator.hasNext()) &#123;</span><br><span class="line">         Integer x = iterator.next();</span><br><span class="line">         System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<h4 id="switch字符串"><a href="#switch字符串" class="headerlink" title="switch字符串"></a>switch字符串</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo6 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      String str = &quot;hello&quot;;</span><br><span class="line">      switch (str) &#123;</span><br><span class="line">         case &quot;hello&quot; :</span><br><span class="line">            System.out.println(&quot;h&quot;);</span><br><span class="line">            break;</span><br><span class="line">         case &quot;world&quot; :</span><br><span class="line">            System.out.println(&quot;w&quot;);</span><br><span class="line">            break;</span><br><span class="line">         default:</span><br><span class="line">            break;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>在编译器中执行的操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo6 &#123;</span><br><span class="line">   public Demo6() &#123;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      String str = &quot;hello&quot;;</span><br><span class="line">      int x = -1;</span><br><span class="line">      //通过字符串的hashCode+value来判断是否匹配</span><br><span class="line">      switch (str.hashCode()) &#123;</span><br><span class="line">         //hello的hashCode</span><br><span class="line">         case 99162322 :</span><br><span class="line">            //再次比较，因为字符串的hashCode有可能相等</span><br><span class="line">            if(str.equals(&quot;hello&quot;)) &#123;</span><br><span class="line">               x = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">         //world的hashCode</span><br><span class="line">         case 11331880 :</span><br><span class="line">            if(str.equals(&quot;world&quot;)) &#123;</span><br><span class="line">               x = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">         default:</span><br><span class="line">            break;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //用第二个switch在进行输出判断</span><br><span class="line">      switch (x) &#123;</span><br><span class="line">         case 0:</span><br><span class="line">            System.out.println(&quot;h&quot;);</span><br><span class="line">            break;</span><br><span class="line">         case 1:</span><br><span class="line">            System.out.println(&quot;w&quot;);</span><br><span class="line">            break;</span><br><span class="line">         default:</span><br><span class="line">            break;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>过程说明：</p>
<ul>
<li>在编译期间，单个的switch被分为了两个<ul>
<li>第一个用来匹配字符串，并给x赋值<ul>
<li>字符串的匹配用到了字符串的hashCode，还用到了equals方法</li>
<li>使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）</li>
</ul>
</li>
<li>第二个用来根据x的值来决定输出语句</li>
</ul>
</li>
</ul>
<h4 id="switch枚举"><a href="#switch枚举" class="headerlink" title="switch枚举"></a>switch枚举</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo7 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      SEX sex = SEX.MALE;</span><br><span class="line">      switch (sex) &#123;</span><br><span class="line">         case MALE:</span><br><span class="line">            System.out.println(&quot;man&quot;);</span><br><span class="line">            break;</span><br><span class="line">         case FEMALE:</span><br><span class="line">            System.out.println(&quot;woman&quot;);</span><br><span class="line">            break;</span><br><span class="line">         default:</span><br><span class="line">            break;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum SEX &#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>编译器中执行的代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo7 &#123;</span><br><span class="line">   /**     </span><br><span class="line">    * 定义一个合成类（仅 jvm 使用，对我们不可见）     </span><br><span class="line">    * 用来映射枚举的 ordinal 与数组元素的关系     </span><br><span class="line">    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     </span><br><span class="line">    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     </span><br><span class="line">    */ </span><br><span class="line">   static class $MAP &#123;</span><br><span class="line">      //数组大小即为枚举元素个数，里面存放了case用于比较的数字</span><br><span class="line">      static int[] map = new int[2];</span><br><span class="line">      static &#123;</span><br><span class="line">         //ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1</span><br><span class="line">         map[SEX.MALE.ordinal()] = 1;</span><br><span class="line">         map[SEX.FEMALE.ordinal()] = 2;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      SEX sex = SEX.MALE;</span><br><span class="line">      //将对应位置枚举元素的值赋给x，用于case操作</span><br><span class="line">      int x = $MAP.map[sex.ordinal()];</span><br><span class="line">      switch (x) &#123;</span><br><span class="line">         case 1:</span><br><span class="line">            System.out.println(&quot;man&quot;);</span><br><span class="line">            break;</span><br><span class="line">         case 2:</span><br><span class="line">            System.out.println(&quot;woman&quot;);</span><br><span class="line">            break;</span><br><span class="line">         default:</span><br><span class="line">            break;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum SEX &#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum SEX &#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>转换后的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class Sex extends Enum&lt;Sex&gt; &#123;   </span><br><span class="line">   //对应枚举类中的元素</span><br><span class="line">   public static final Sex MALE;    </span><br><span class="line">   public static final Sex FEMALE;    </span><br><span class="line">   private static final Sex[] $VALUES;</span><br><span class="line">   </span><br><span class="line">    static &#123;       </span><br><span class="line">    	//调用构造函数，传入枚举元素的值及ordinal</span><br><span class="line">    	MALE = new Sex(&quot;MALE&quot;, 0);    </span><br><span class="line">        FEMALE = new Sex(&quot;FEMALE&quot;, 1);   </span><br><span class="line">        $VALUES = new Sex[]&#123;MALE, FEMALE&#125;; </span><br><span class="line">   &#125;</span><br><span class="line"> 	</span><br><span class="line">   //调用父类中的方法</span><br><span class="line">    private Sex(String name, int ordinal) &#123;     </span><br><span class="line">        super(name, ordinal);    </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public static Sex[] values() &#123;  </span><br><span class="line">        return $VALUES.clone();  </span><br><span class="line">    &#125;</span><br><span class="line">    public static Sex valueOf(String name) &#123; </span><br><span class="line">        return Enum.valueOf(Sex.class, name);  </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo8 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Runnable runnable = new Runnable() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void run() &#123;</span><br><span class="line">            System.out.println(&quot;running...&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>转换后的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo8 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      //用额外创建的类来创建匿名内部类对象</span><br><span class="line">      Runnable runnable = new Demo8$1();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建了一个额外的类，实现了Runnable接口</span><br><span class="line">final class Demo8$1 implements Runnable &#123;</span><br><span class="line">   public Demo8$1() &#123;&#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">      System.out.println(&quot;running...&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>如果匿名内部类中引用了<strong>局部变量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo8 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      int x = 1;</span><br><span class="line">      Runnable runnable = new Runnable() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void run() &#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>转化后代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo8 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      int x = 1;</span><br><span class="line">      Runnable runnable = new Runnable() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void run() &#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final class Demo8$1 implements Runnable &#123;</span><br><span class="line">   //多创建了一个变量</span><br><span class="line">   int val$x;</span><br><span class="line">   //变为了有参构造器</span><br><span class="line">   public Demo8$1(int x) &#123;</span><br><span class="line">      this.val$x = x;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">      System.out.println(val$x);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<h3 id="4、类加载阶段"><a href="#4、类加载阶段" class="headerlink" title="4、类加载阶段"></a>4、类加载阶段</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ul>
<li><p>将类的字节码载入</p>
<p>方法区</p>
<p>（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：</p>
<ul>
<li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用</li>
<li>_super 即父类</li>
<li>_ﬁelds 即成员变量</li>
<li>_methods 即方法</li>
<li>_constants 即常量池</li>
<li>_class_loader 即类加载器</li>
<li>_vtable 虚方法表</li>
<li>_itable 接口方法</li>
</ul>
</li>
<li><p>如果这个类还有父类没有加载，<strong>先加载父类</strong></p>
</li>
<li><p>加载和链接可能是<strong>交替运行</strong>的</p>
</li>
</ul>
<p><img src="/2022/12/17/JVM/20200611205050.png" alt="20200611205050"></p>
<ul>
<li>instanceKlass保存在<strong>方法区</strong>。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li>
<li>_java_mirror则是保存在<strong>堆内存</strong>中</li>
<li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li>
<li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li>
</ul>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>验证类是否符合 JVM规范，安全性检查</p>
<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>为 static 变量分配空间，设置默认值</p>
<ul>
<li>static变量在JDK 7以前是存储与instanceKlass末尾。但在JDK 7以后就存储在_java_mirror末尾了</li>
<li>static变量在分配空间和赋值是在两个阶段完成的。分配空间在准备阶段完成，赋值在初始化阶段完成</li>
<li>如果 static 变量是 ﬁnal 的<strong>基本类型</strong>，以及<strong>字符串常量</strong>，那么编译阶段值就确定了，<strong>赋值在准备阶段完成</strong></li>
<li>如果 static 变量是 ﬁnal 的，但属于<strong>引用类型</strong>，那么赋值也会在<strong>初始化阶段完成</strong></li>
</ul>
<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p><strong>HSDB的使用</strong></p>
<ul>
<li>先获得要查看的进程ID</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jpsCopy</span><br></pre></td></tr></table></figure>

<ul>
<li>打开HSDB</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -cp F:\JAVA\JDK8.0\lib\sa-jdi.jar sun.jvm.hotspot.HSDBCopy</span><br></pre></td></tr></table></figure>

<ul>
<li>运行时可能会报错，是因为<strong>缺少一个.dll的文件</strong>，我们在JDK的安装目录中找到该文件，复制到缺失的文件下即可</li>
</ul>
<p><img src="/2022/12/17/JVM/20200611221703.png" alt="20200611221703"></p>
<ul>
<li>定位需要的进程</li>
</ul>
<p><img src="/2022/12/17/JVM/20200611221857.png" alt="20200611221857"></p>
<p><img src="/2022/12/17/JVM/20200611222029.png" alt="20200611222029"></p>
<p><strong>解析的含义</strong></p>
<p>将常量池中的符号引用解析为直接引用</p>
<ul>
<li>未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">   public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">      ClassLoader loader = Demo1.class.getClassLoader();</span><br><span class="line">      //只加载不解析</span><br><span class="line">      Class&lt;?&gt; c = loader.loadClass(&quot;com.nyima.JVM.day8.C&quot;);</span><br><span class="line">      //用于阻塞主线程</span><br><span class="line">      System.in.read();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C &#123;</span><br><span class="line">   D d = new D();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class D &#123;</span><br><span class="line"></span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>打开HSDB<ul>
<li>可以看到此时只加载了类C</li>
</ul>
</li>
</ul>
<p><img src="/2022/12/17/JVM/20200611223153.png" alt="20200611223153"></p>
<p>查看类C的常量池，可以看到类D<strong>未被解析</strong>，只是存在于常量池中的符号</p>
<p><img src="/2022/12/17/JVM/20200611230658.png" alt="20200611230658"></p>
<ul>
<li><p>解析以后，会将常量池中的符号引用解析为直接引用</p>
<ul>
<li>可以看到，此时已加载并解析了类C和类D</li>
</ul>
<p><img src="/2022/12/17/JVM/20200611223441.png" alt="20200611223441"></p>
</li>
</ul>
<p><img src="/2022/12/17/JVM/20200613104723.png" alt="20200613104723"></p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化阶段就是<strong>执行类构造器clinit()方法的过程</strong>，虚拟机会保证这个类的『构造方法』的线程安全</p>
<ul>
<li>clinit()方法是由编译器自动收集类中的所有类变量的<strong>赋值动作和静态语句块</strong>（static{}块）中的语句合并产生的</li>
</ul>
<p><strong>注意</strong></p>
<p>编译器收集的顺序是由语句在源文件中<strong>出现的顺序决定</strong>的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它<strong>之后</strong>的变量，在前面的静态语句块<strong>可以赋值，但是不能访问</strong>，如</p>
<p><img src="/2022/12/17/JVM/20201118204542.png" alt="20201118204542"></p>
<h5 id="发生时机"><a href="#发生时机" class="headerlink" title="发生时机"></a>发生时机</h5><p><strong>类的初始化的懒惰的</strong>，以下情况会初始化</p>
<ul>
<li>main 方法所在的类，总会被首先初始化</li>
<li>首次访问这个类的静态变量或静态方法时</li>
<li>子类初始化，如果父类还没初始化，会引发</li>
<li>子类访问父类的静态变量，只会触发父类的初始化</li>
<li>Class.forName</li>
<li>new 会导致初始化</li>
</ul>
<p>以下情况不会初始化</p>
<ul>
<li>访问类的 static ﬁnal 静态常量（基本类型和字符串）</li>
<li>类对象.class 不会触发初始化</li>
<li>创建该类对象的数组</li>
<li>类加载器的.loadClass方法</li>
<li>Class.forNamed的参数2为false时</li>
</ul>
<p><strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong></p>
<h3 id="5、类加载器"><a href="#5、类加载器" class="headerlink" title="5、类加载器"></a>5、类加载器</h3><p>Java虚拟机设计团队有意把类加载阶段中的<strong>“通过一个类的全限定名来获取描述该类的二进制字节流”</strong>这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为<strong>“类加载器”</strong>（ClassLoader）</p>
<h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段</p>
<p>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：<strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等</p>
<p>以JDK 8为例</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>加载的类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Bootstrap ClassLoader（启动类加载器）</td>
<td>JAVA_HOME&#x2F;jre&#x2F;lib</td>
<td>无法直接访问</td>
</tr>
<tr>
<td>Extension ClassLoader(拓展类加载器)</td>
<td>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</td>
<td>上级为Bootstrap，<strong>显示为null</strong></td>
</tr>
<tr>
<td>Application ClassLoader(应用程序类加载器)</td>
<td>classpath</td>
<td>上级为Extension</td>
</tr>
<tr>
<td>自定义类加载器</td>
<td>自定义</td>
<td>上级为Application</td>
</tr>
</tbody></table>
<h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><p>可通过在控制台输入指令，使得类被启动类加器加载</p>
<h4 id="拓展类加载器"><a href="#拓展类加载器" class="headerlink" title="拓展类加载器"></a>拓展类加载器</h4><p>如果classpath和JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext 下有同名类，加载时会使用<strong>拓展类加载器</strong>加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载</p>
<h4 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h4><p>双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则</p>
<p>loadClass源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">    throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">        // 首先查找该类是否已经被该类加载器加载过了</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        //如果没有被加载过</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            long t0 = System.nanoTime();</span><br><span class="line">            try &#123;</span><br><span class="line">                //看是否被它的上级加载器加载过了 Extension的上级是Bootstarp，但它显示为null</span><br><span class="line">                if (parent != null) &#123;</span><br><span class="line">                    c = parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //看是否被启动类加载器加载过</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                // ClassNotFoundException thrown if class not found</span><br><span class="line">                // from the non-null parent class loader</span><br><span class="line">                //捕获异常，但不做任何处理</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                //如果还是没有找到，先让拓展类加载器调用findClass方法去找到该类，如果还是没找到，就抛出异常</span><br><span class="line">                //然后让应用类加载器去找classpath下找该类</span><br><span class="line">                long t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                // 记录时间</span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul>
<li>想加载非 classpath 随意路径中的类文件</li>
<li>通过接口来使用实现，希望解耦时，常用在框架设计</li>
<li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li>
</ul>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul>
<li>继承ClassLoader父类</li>
<li>要遵从双亲委派机制，重写 ﬁndClass 方法<ul>
<li>不是重写loadClass方法，否则不会走双亲委派机制</li>
</ul>
</li>
<li>读取类文件的字节码</li>
<li>调用父类的 deﬁneClass 方法来加载类</li>
<li>使用者调用该类加载器的 loadClass 方法</li>
</ul>
<h4 id="破坏双亲委派模式"><a href="#破坏双亲委派模式" class="headerlink" title="破坏双亲委派模式"></a>破坏双亲委派模式</h4><ul>
<li>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代<ul>
<li>建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法</li>
</ul>
</li>
<li>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的<ul>
<li>如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式</li>
</ul>
</li>
<li>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的<ul>
<li>这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</li>
</ul>
</li>
</ul>
<h3 id="6、运行期优化"><a href="#6、运行期优化" class="headerlink" title="6、运行期优化"></a>6、运行期优化</h3><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p>JVM 将执行状态分成了 5 个层次：</p>
<ul>
<li>0层：解释执行，用解释器将字节码翻译为机器码</li>
<li>1层：使用 C1 <strong>即时编译器</strong>编译执行（不带 proﬁling）</li>
<li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li>
<li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li>
<li>4层：使用 C2 即时编译器编译执行</li>
</ul>
<p>proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等</p>
<h5 id="即时编译器（JIT）与解释器的区别"><a href="#即时编译器（JIT）与解释器的区别" class="headerlink" title="即时编译器（JIT）与解释器的区别"></a>即时编译器（JIT）与解释器的区别</h5><ul>
<li>解释器<ul>
<li>将字节码<strong>解释</strong>为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li>
<li>是将字节码解释为针对所有平台都通用的机器码</li>
</ul>
</li>
<li>即时编译器<ul>
<li>将一些字节码<strong>编译</strong>为机器码，<strong>并存入 Code Cache</strong>，下次遇到相同的代码，直接执行，无需再编译</li>
<li>根据平台类型，生成平台特定的机器码</li>
</ul>
</li>
</ul>
<p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码</p>
<h5 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h5><p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术</p>
<p>逃逸分析的 JVM 参数如下：</p>
<ul>
<li>开启逃逸分析：-XX:+DoEscapeAnalysis</li>
<li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li>
<li>显示分析结果：-XX:+PrintEscapeAnalysis</li>
</ul>
<p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数</p>
<p><strong>对象逃逸状态</strong></p>
<p><strong>全局逃逸（GlobalEscape）</strong></p>
<ul>
<li>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：<ul>
<li>对象是一个静态变量</li>
<li>对象是一个已经发生逃逸的对象</li>
<li>对象作为当前方法的返回值</li>
</ul>
</li>
</ul>
<p><strong>参数逃逸（ArgEscape）</strong></p>
<ul>
<li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</li>
</ul>
<p><strong>没有逃逸</strong></p>
<ul>
<li>即方法中的对象没有发生逃逸</li>
</ul>
<p><strong>逃逸分析优化</strong></p>
<p>针对上面第三点，当一个对象<strong>没有逃逸</strong>时，可以得到以下几个虚拟机的优化</p>
<p><strong>锁消除</strong></p>
<p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁</p>
<p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作</p>
<p>锁消除的 JVM 参数如下：</p>
<ul>
<li>开启锁消除：-XX:+EliminateLocks</li>
<li>关闭锁消除：-XX:-EliminateLocks</li>
</ul>
<p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p>
<p><strong>标量替换</strong></p>
<p>首先要明白标量和聚合量，<strong>基础类型</strong>和<strong>对象的引用</strong>可以理解为<strong>标量</strong>，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象</p>
<p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做<strong>标量替换</strong>。</p>
<p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能</p>
<p>标量替换的 JVM 参数如下：</p>
<ul>
<li>开启标量替换：-XX:+EliminateAllocations</li>
<li>关闭标量替换：-XX:-EliminateAllocations</li>
<li>显示标量替换详情：-XX:+PrintEliminateAllocations</li>
</ul>
<p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p>
<p><strong>栈上分配</strong></p>
<p>当对象没有发生逃逸时，该<strong>对象</strong>就可以通过标量替换分解成成员标量分配在<strong>栈内存</strong>中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能</p>
<h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><h5 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a><strong>内联函数</strong></h5><p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p>
<h5 id="JVM内联函数"><a href="#JVM内联函数" class="headerlink" title="JVM内联函数"></a><strong>JVM内联函数</strong></h5><p>C++是否为内联函数由自己决定，Java由<strong>编译器决定</strong>。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字<strong>final修饰</strong> 用来指明那个函数是希望被JVM内联的，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final void doSomething() &#123;  </span><br><span class="line">        // to do something  </span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</p>
<p>JVM内建有许多运行时优化。首先<strong>短方法</strong>更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。</p>
<p>第二个原因则更重要：<strong>方法内联</strong></p>
<p>如果JVM监测到一些<strong>小方法被频繁的执行</strong>，它会把方法的调用替换成方法体本身，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private int add4(int x1, int x2, int x3, int x4) &#123; </span><br><span class="line">		//这里调用了add2方法</span><br><span class="line">        return add2(x1, x2) + add2(x3, x4);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    private int add2(int x1, int x2) &#123;  </span><br><span class="line">        return x1 + x2;  </span><br><span class="line">    &#125;Copy</span><br></pre></td></tr></table></figure>

<p>方法调用被替换后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private int add4(int x1, int x2, int x3, int x4) &#123;  </span><br><span class="line">    	//被替换为了方法本身</span><br><span class="line">        return x1 + x2 + x3 + x4;  </span><br><span class="line">    &#125;Copy</span><br></pre></td></tr></table></figure>

<h4 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Reflect1 &#123;</span><br><span class="line">   public static void foo() &#123;</span><br><span class="line">      System.out.println(&quot;foo...&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">      Method foo = Demo3.class.getMethod(&quot;foo&quot;);</span><br><span class="line">      for(int i = 0; i&lt;=16; i++) &#123;</span><br><span class="line">         foo.invoke(null);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现</p>
<p>invoke方法源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@CallerSensitive</span><br><span class="line">public Object invoke(Object obj, Object... args)</span><br><span class="line">    throws IllegalAccessException, IllegalArgumentException,</span><br><span class="line">       InvocationTargetException</span><br><span class="line">&#123;</span><br><span class="line">    if (!override) &#123;</span><br><span class="line">        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类</span><br><span class="line">    MethodAccessor ma = methodAccessor;             // read volatile</span><br><span class="line">    if (ma == null) &#123;</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    return ma.invoke(obj, args);</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p><img src="/2022/12/17/JVM/20200614133554.png" alt="20200614133554"></p>
<p>会由DelegatingMehodAccessorImpl去调用NativeMethodAccessorImpl</p>
<p>NativeMethodAccessorImpl源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class NativeMethodAccessorImpl extends MethodAccessorImpl &#123;</span><br><span class="line">    private final Method method;</span><br><span class="line">    private DelegatingMethodAccessorImpl parent;</span><br><span class="line">    private int numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeMethodAccessorImpl(Method var1) &#123;</span><br><span class="line">        this.method = var1;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	//每次进行反射调用，会让numInvocation与ReflectionFactory.inflationThreshold的值（15）进行比较，并使使得numInvocation的值加一</span><br><span class="line">	//如果numInvocation&gt;ReflectionFactory.inflationThreshold，则会调用本地方法invoke0方法</span><br><span class="line">    public Object invoke(Object var1, Object[] var2) throws IllegalArgumentException, InvocationTargetException &#123;</span><br><span class="line">        if (++this.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(this.method.getDeclaringClass())) &#123;</span><br><span class="line">            MethodAccessorImpl var3 = (MethodAccessorImpl)(new MethodAccessorGenerator()).generateMethod(this.method.getDeclaringClass(), this.method.getName(), this.method.getParameterTypes(), this.method.getReturnType(), this.method.getExceptionTypes(), this.method.getModifiers());</span><br><span class="line">            this.parent.setDelegate(var3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return invoke0(this.method, var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setParent(DelegatingMethodAccessorImpl var1) &#123;</span><br><span class="line">        this.parent = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static native Object invoke0(Method var0, Object var1, Object[] var2);</span><br><span class="line">&#125;Copy</span><br><span class="line">//ReflectionFactory.inflationThreshold()方法的返回值</span><br><span class="line">private static int inflationThreshold = 15;Copy</span><br></pre></td></tr></table></figure>

<ul>
<li><p>一开始if条件不满足，就会调用本地方法invoke0</p>
</li>
<li><p>随着numInvocation的增大，当它大于ReflectionFactory.inflationThreshold的值16时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率</p>
<ul>
<li>这时会从反射调用变为<strong>正常调用</strong>，即直接调用 Reflect1.foo()</li>
</ul>
<p><img src="/2022/12/17/JVM/20200614135011.png" alt="20200614135011"></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
